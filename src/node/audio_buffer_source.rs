use std::sync::atomic::{Ordering, AtomicBool};
use std::sync::Arc;
use crossbeam_channel::{Receiver, Sender};

use crate::audio_buffer::{AudioBuffer};
use crate::context::{AsBaseAudioContext, AudioContextRegistration, AudioParamId};
use crate::param::{AudioParam, AudioParamOptions, AutomationRate};
use crate::render::{AudioParamValues, AudioProcessor, AudioRenderQuantum};
use crate::{SampleRate, RENDER_QUANTUM_SIZE, AtomicF64};

use super::{
    AudioNode, ChannelConfig, ChannelConfigOptions,
};

// attributes shared between the node and the renderer
//
// @note - kind of pack both Scheduler and Controller with an additionnal
//  `duration` entry and `seek` renamed to `offset`
// @note - this could probably be generated by a macro! (`Vec<{name, default<type>}>`)
//  maybe another macro could also help for Getters and Setters on the node itself
#[derive(Clone, Debug)]
struct SharedAttributes {
    start: Arc<AtomicF64>,
    stop: Arc<AtomicF64>,
    offset: Arc<AtomicF64>,
    duration: Arc<AtomicF64>,
    loop_: Arc<AtomicBool>,
    loop_start: Arc<AtomicF64>,
    loop_end: Arc<AtomicF64>,
}

impl Default for SharedAttributes {
    fn default() -> Self {
        Self {
            start: Arc::new(AtomicF64::new(0.)),
            stop: Arc::new(AtomicF64::new(f64::MAX)),
            offset: Arc::new(AtomicF64::new(0.)),
            duration: Arc::new(AtomicF64::new(f64::MAX)),
            loop_: Arc::new(AtomicBool::new(false)),
            loop_start: Arc::new(AtomicF64::new(0.)),
            loop_end: Arc::new(AtomicF64::new(0.)),
        }
    }
}

impl SharedAttributes {
    fn get_start(&self, ) -> f64 {
        self.start.load()
    }
    fn set_start(&self, value: f64) {
        self.start.store(value);
    }

    fn get_stop(&self, ) -> f64 {
        self.stop.load()
    }

    fn set_stop(&self, value: f64) {
        self.stop.store(value);
    }

    fn get_offset(&self, ) -> f64 {
        self.offset.load()
    }

    fn set_offset(&self, value: f64) {
        self.offset.store(value);
    }

    fn get_duration(&self, ) -> f64 {
        self.duration.load()
    }

    fn set_duration(&self, value: f64) {
        self.duration.store(value);
    }

    fn get_loop(&self, ) -> bool {
        self.loop_.load(Ordering::SeqCst)
    }

    fn set_loop(&self, value: bool) {
        self.loop_.store(value, Ordering::SeqCst);
    }

    fn get_loop_start(&self, ) -> f64 {
        self.loop_start.load()
    }

    fn set_loop_start(&self, value: f64) {
        self.loop_start.store(value);
    }

    fn get_loop_end(&self, ) -> f64 {
        self.loop_end.load()
    }

    fn set_loop_end(&self, value: f64) {
        self.loop_end.store(value);
    }
}

pub struct AudioBufferSourceOptions {
    pub buffer: Option<AudioBuffer>,
    pub detune: f32,
    pub loop_: bool,
    pub loop_start: f64,
    pub loop_end: f64,
    pub playback_rate: f32,
    pub channel_config: ChannelConfigOptions,
}

impl Default for AudioBufferSourceOptions {
    fn default() -> Self {
        Self {
            buffer: None,
            detune: 0.,
            loop_: false,
            loop_start: 0.,
            loop_end: 0.,
            playback_rate: 1.,
            channel_config: Default::default(),
        }
    }
}

// channels & duration
struct BufferChannelsMessage(Vec<Arc<Vec<f32>>>, f64);

pub struct AudioBufferSourceNode {
    registration: AudioContextRegistration,
    attributes: SharedAttributes,
    channel_config: ChannelConfig,
    sender: Sender<BufferChannelsMessage>,
    detune: AudioParam, // has constraints, no a-rate
    playback_rate: AudioParam, // has constraints, no a-rate
    buffer: Option<AudioBuffer>,
    source_started: bool,
}

impl AudioNode for AudioBufferSourceNode {
    fn registration(&self) -> &AudioContextRegistration {
        &self.registration
    }

    fn channel_config_raw(&self) -> &ChannelConfig {
        &self.channel_config
    }

    fn number_of_inputs(&self) -> u32 {
        0
    }
    fn number_of_outputs(&self) -> u32 {
        1
    }
}

impl AudioBufferSourceNode {
    pub fn new<C: AsBaseAudioContext>(context: &C, options: AudioBufferSourceOptions) -> Self {
        // create render and register all that in the context
        context.base().register(move |registration| {
            // @todo - hndle options
            let AudioBufferSourceOptions {
                buffer,
                detune,
                loop_,
                loop_start,
                loop_end,
                playback_rate,
                channel_config,
            } = options;

            // @todo - these parameters can't be changed to a-rate
            // @see - <https://webaudio.github.io/web-audio-api/#audioparam-automation-rate-constraints>
            let detune_param_options = AudioParamOptions {
                min_value: f32::MIN,
                max_value: f32::MAX,
                default_value: 0.,
                automation_rate: AutomationRate::K,
            };
            let (d_param, d_proc) = context
                .base()
                .create_audio_param(detune_param_options, registration.id());

            d_param.set_value(detune);

            let playback_rate_param_options = AudioParamOptions {
                min_value: f32::MIN,
                max_value: f32::MAX,
                default_value: 1.,
                automation_rate: AutomationRate::K,
            };
            let (pr_param, pr_proc) = context
                .base()
                .create_audio_param(playback_rate_param_options, registration.id());

            pr_param.set_value(playback_rate);

            // Channel to send buffer channels references to the renderer
            //
            // @note: Maybe we don't want to block the control thread waiting for next
            // `render.tick`? However it's probably better to block the control thread
            // rather than the render thread...
            // Wouldn't be feasible to spawn a middle man thread that could block?
            // ```
            // let (sender, receiver) = crossbeam_channel::bounded(0);
            // thread::spawn(move || {
            //     sender.send(data); // this thread could block waiting for the render thread
            // });
            // ```
            // ...but maybe this could introduce strange race conditions, or
            // performance penalty, I don't know...
            //
            // @note - for some reason it blocks the rendering in tests w/ offline audio context
            //  maybe because of early return in case of `none` buffer
            let (sender, receiver) = crossbeam_channel::bounded(1);

            // `scheduler` and `controller` are not really suited as we also need
            // to store a `duration` here and `seek` should be renamed to `offset`,
            // also leads to a cleaner API IMO.
            // @note - maybe this approach could be generalized w/ a macro
            let shared_attributes = SharedAttributes::default();

            let renderer = AudioBufferSourceRenderer {
                attributes: shared_attributes.clone(),
                receiver,
                // @todo - just grab a deep clone of the buffer would be far more simple...
                // need to make sure how clone behave with nested structures
                buffer: None,
                buffer_duration: None,
                detune: d_proc,
                playback_rate: pr_proc,
                render_state: AudioBufferRendererState::default(),
                // 2 channels is sufficient for most use-cases, the `vec` will be
                // resized to actual buffer number_of_channels when buffer is received
                // on the render thread
                internal_buffer: Vec::<f32>::with_capacity(2),
            };

            let mut node = Self {
                registration,
                attributes: shared_attributes,
                channel_config: channel_config.into(),
                sender,
                detune: d_param,
                playback_rate: pr_param,
                buffer: None,
                source_started: false,
            };

            node.attributes.set_loop(loop_);
            node.attributes.set_loop_start(loop_start);
            node.attributes.set_loop_end(loop_end);

            if buffer.is_some() {
                node.set_buffer(&buffer.unwrap());
            }

            (node, Box::new(renderer))
        })
    }

    pub fn set_buffer(&mut self, audio_buffer: &AudioBuffer) {
        // - Let new buffer be the AudioBuffer or null value to be assigned to buffer.
        // - If new buffer is not null and [[buffer set]] is true, throw an
        // InvalidStateError and abort these steps.
        if self.buffer.is_some() {
            // buffer has already been set, panic!
            panic!("InvalidStateError - cannot assign buffer twice");
        }
        // - If new buffer is not null, set [[buffer set]] to true.
        // - Assign new buffer to the buffer attribute.
        self.buffer = Some(audio_buffer.clone());
        // - If start() has previously been called on this node, perform the
        // operation acquire the content on buffer.
        if self.source_started {
            self.acquire_buffer_channels();
        }
    }

    pub fn start(&mut self) {
        let start = self.registration.context().current_time();
        self.start_at(start);
    }

    pub fn start_at(&mut self, start: f64) {
        if self.source_started {
            panic!("InvalidStateError: Cannot call `start` twice");
        }

        self.source_started = true;
        self.acquire_buffer_channels();
        self.attributes.set_start(start);
    }

    pub fn start_at_with_offset(&mut self, start: f64, offset: f64) {
        self.attributes.set_offset(offset);
        self.start_at(start);
    }

    pub fn start_at_with_offset_and_duration(&mut self, start: f64, offset: f64, duration: f64) {
        self.attributes.set_offset(offset);
        self.attributes.set_duration(duration);
        self.start_at(start);
    }

    pub fn stop(&mut self) {
        let stop = self.registration.context().current_time();
        self.stop_at(stop);
    }

    pub fn stop_at(&mut self, stop: f64) {
        // https://webaudio.github.io/web-audio-api/#dom-audioscheduledsourcenode-stop
        if self.source_started == false {
            panic!("InvalidStateError cannot stop before start");
        }

        self.attributes.set_stop(stop)
    }

    pub fn playback_rate(&self) -> &AudioParam {
        &self.playback_rate
    }

    pub fn detune(&self) -> &AudioParam {
        &self.detune
    }

    pub fn loop_(&self) -> bool {
        self.attributes.get_loop()
    }

    pub fn set_loop(&self, value: bool) {
        self.attributes.set_loop(value);
    }

    pub fn loop_start(&self) -> f64 {
        self.attributes.get_loop_start()
    }

    pub fn set_loop_start(&self, value: f64) {
        self.attributes.set_loop_start(value);
    }

    pub fn loop_end(&self) -> f64 {
        self.attributes.get_loop_end()
    }

    pub fn set_loop_end(&self, value: f64) {
        self.attributes.set_loop_end(value);
    }

    // create a new Vec<Arc<Vec<f32>>> containing cloned `Arc` references from
    // current `AudioBuffer.internal_data` so that if `set_channel_data` is
    // called while the source is playing, it won't be impacted.
    //
    // cf. https://webaudio.github.io/web-audio-api/#acquire-the-content
    //
    // @note - maybe this step is not necessary as the `Arc`s are already
    // cloned in `set_buffer`? can't find information about nested clones
    // @note - if required, this logic should live in `AudioBuffer` to be reused
    // by `ConvolverNode`
    fn acquire_buffer_channels(&self) {
        let buffer = self.buffer.as_ref().unwrap();
        let number_of_channels = buffer.number_of_channels();
        let duration = buffer.duration();
        let mut channels = Vec::<Arc<Vec<f32>>>::with_capacity(number_of_channels);

         for channel_number in 0..number_of_channels {
            let channel = buffer.get_channel_clone(channel_number);
            channels.push(channel);
        }

        self.sender
            .send(BufferChannelsMessage(channels, duration))
            .expect("Sending BufferChannelsMessage failed");
    }
}

struct AudioBufferRendererState {
    buffer_time: f64,
    started: bool,
    entered_loop: bool,
    buffer_time_elapsed: f64,
}

impl Default for AudioBufferRendererState {
    fn default() -> Self {
        Self {
            buffer_time: 0.,
            started: false,
            entered_loop: false,
            buffer_time_elapsed: 0.,
        }
    }
}

struct AudioBufferSourceRenderer {
    attributes: SharedAttributes,
    receiver: Receiver<BufferChannelsMessage>,
    buffer: Option<Vec<Arc<Vec<f32>>>>,
    buffer_duration: Option<f64>,
    detune: AudioParamId,
    playback_rate: AudioParamId,
    render_state: AudioBufferRendererState,
    internal_buffer: Vec<f32>,
}

impl AudioProcessor for AudioBufferSourceRenderer {
    fn process(
        &mut self,
        _inputs: &[AudioRenderQuantum], // no input
        outputs: &mut [AudioRenderQuantum],
        params: AudioParamValues,
        timestamp: f64,
        sample_rate: SampleRate,
    ) -> bool {
        // single output node
        let output = &mut outputs[0];

        let dt = 1. / sample_rate.0 as f64;
        let num_frames = RENDER_QUANTUM_SIZE;
        let next_block_time = timestamp + dt * RENDER_QUANTUM_SIZE as f64;

        // check if we received some buffer_channels
        if let Ok(msg) = self.receiver.try_recv() {
            self.buffer = Some(msg.0);
            self.buffer_duration = Some(msg.1);

            let number_of_channels = self.buffer.as_ref().unwrap().len();
            self.internal_buffer.resize(number_of_channels, 0.);
        }

        let detune_values = params.get(&self.detune);
        let playback_rate_values = params.get(&self.playback_rate);
        // compute compound parameter at k-rate
        let detune = detune_values[0];
        let playback_rate = playback_rate_values[0];
        let computed_playback_rate = (playback_rate * 2_f32.powf(detune / 1200.)) as f64;

        let start_time = self.attributes.get_start();
        let stop_time = self.attributes.get_stop();
        let mut offset = self.attributes.get_offset();
        let duration = self.attributes.get_duration();
        let loop_ = self.attributes.get_loop();
        let loop_start = self.attributes.get_loop_start();
        let loop_end = self.attributes.get_loop_end();

        // will only be used if `loop_` is true anyway, so no need for `Option`
        let mut actual_loop_start = 0.;
        let mut actual_loop_end = 0.;

        // return early if start_time is beyond this block
        if start_time >= next_block_time {
            output.make_silent();
            return true;
        }

        // @todo - not sure this behave as it should, maybe return true and
        // wait for the buffer. Need to check how browsers behave on that
        if self.buffer.is_none() {
            output.make_silent();
            return false;
        }

        // In addition, if the buffer has more than one channel, then the
        // AudioBufferSourceNode output must change to a single channel of silence
        // at the beginning of a render quantum after the time at which any one of
        // the following conditions holds:
        let buffer_duration = self.buffer_duration.unwrap();

        // - the stop time has been reached.
        // - the duration has been reached.
        if timestamp >= stop_time
            || self.render_state.buffer_time_elapsed >= duration
        {
            // println!("reached stopTime or duration, return false");
            output.make_silent();
            return false;
        }

        // - the end of the buffer has been reached.
        if loop_ == false {
            // forward playback rate
            if computed_playback_rate > 0.
                && self.render_state.buffer_time >= buffer_duration
            {
                // println!("reached end of file, return false");
                output.make_silent();
                return false;
            }

            // backward playback rate
            if computed_playback_rate < 0.
                && self.render_state.buffer_time < 0.
            {
                // println!("reached end of file (backward), return false");
                output.make_silent();
                return false;
            }

        }

        let num_channels = self.buffer.as_ref().unwrap().len();
        output.set_number_of_channels(num_channels);

        // go through the algorithm described in the spec
        // @see <https://webaudio.github.io/web-audio-api/#playback-AudioBufferSourceNode>
        let mut current_time = timestamp;

        if loop_ == true && self.buffer.is_some() {
            if loop_start >= 0. && loop_end > 0. && loop_start < loop_end {
                actual_loop_start = loop_start;
                actual_loop_end = loop_end.min(buffer_duration);
            } else {
                actual_loop_start = 0.;
                actual_loop_end = buffer_duration;
            }
        } else {
            self.render_state.entered_loop = false;
        }

        for index in 0..num_frames {
            if current_time < start_time
                || current_time >= stop_time
                || self.render_state.buffer_time_elapsed >= duration {
                self.internal_buffer.fill(0.);
                output.set_channels_values_at(index, &self.internal_buffer);
                continue; // nothing more to do for this sample
            }

            // we have reached start time
            if self.render_state.started == false {
                if loop_ && computed_playback_rate >= 0. && offset >= actual_loop_end {
                    offset = actual_loop_end;
                }

                if loop_ && computed_playback_rate < 0. && offset < actual_loop_start {
                    offset = actual_loop_start;
                }

                self.render_state.buffer_time = offset;
                self.render_state.started = true;
            }

            if loop_ == true {
                if self.render_state.entered_loop == false {
                    // playback began before or within loop, and playhead is now past loop start
                    if offset < actual_loop_end && self.render_state.buffer_time >= actual_loop_start {
                        self.render_state.entered_loop = true;
                    }

                    // playback began after loop, and playhead is now prior to the loop end
                    // @note - only possible when playback_rate < 0 (?)
                    if offset >= actual_loop_end && self.render_state.buffer_time < actual_loop_end {
                        self.render_state.entered_loop = true;
                    }
                }

                // check loop boundaries
                if self.render_state.entered_loop {
                    while self.render_state.buffer_time >= actual_loop_end {
                        self.render_state.buffer_time -= actual_loop_end - actual_loop_start;
                    }

                    while self.render_state.buffer_time < actual_loop_start {
                        self.render_state.buffer_time += actual_loop_end - actual_loop_start;
                    }
                }
            }

            if self.render_state.buffer_time >= 0.
                && self.render_state.buffer_time < buffer_duration {

                self.compute_playback_at_position(
                    self.render_state.buffer_time,
                    sample_rate.0 as f64,
                );

                output.set_channels_values_at(index, &self.internal_buffer);
            } else {
                self.internal_buffer.fill(0.);
                output.set_channels_values_at(index, &self.internal_buffer);
            }

            self.render_state.buffer_time += dt * computed_playback_rate;
            self.render_state.buffer_time_elapsed += dt * computed_playback_rate;
            current_time += dt;
        }


        true
    }
}

impl AudioBufferSourceRenderer {
    // Pick the index closer to the given position
    // @note keep it around as it could be usefull for testing and used to
    // for perf improvement if the playback is aligned on `sample_rate` and
    // `playback_rate.abs() = 1`
    #[allow(dead_code)]
    fn compute_playback_at_position_direct(
        &mut self,
        position: f64,
        sample_rate: f64,
    ) {
        let buffer_channels = self.buffer.as_ref().unwrap();
        let sample_index = (position * sample_rate).round() as usize;

        for (channel_index, channel) in buffer_channels.iter().enumerate() {
            self.internal_buffer[channel_index] = channel[sample_index];
        }
    }

    // Linear interpolation according to position
    fn compute_playback_at_position(
        &mut self,
        position: f64,
        sample_rate: f64,
    ) {
        let buffer_channels = self.buffer.as_ref().unwrap();
        let playhead = position * sample_rate;
        let playhead_floored = playhead.floor();
        let prev_index = playhead_floored as usize;   // can't be < 0.
        let next_index = playhead.ceil() as usize;    // can be >= length

        let k = (playhead - playhead_floored) as f32;
        let k_inv = 1. - k;

        for (channel_index, channel) in buffer_channels.iter().enumerate() {
            // @note - [spec] If |position| is greater than or equal to |loopEnd|
            // and there is no subsequent sample frame in buffer, then interpolation
            // should be based on the sequence of subsequent frames beginning at |loopStart|.
            //
            // for now let's just interpolate with zero, does the job
            let prev_sample = channel[prev_index];
            let next_sample = if next_index >= channel.len() { 0. } else { channel[next_index] };
            let value = k_inv * prev_sample + k * next_sample;
            self.internal_buffer[channel_index] = value;
        }
    }
}

#[cfg(test)]
mod tests {

    use crate::context::{OfflineAudioContext, AsBaseAudioContext};
    use crate::audio_buffer::decode_audio_data;
    use crate::{SampleRate, RENDER_QUANTUM_SIZE};
    use crate::node::{AudioNode};

    use float_eq::assert_float_eq;

    #[test]
    fn type_playing_some_file() {
        let mut context = OfflineAudioContext::new(2, RENDER_QUANTUM_SIZE * 1, SampleRate(44_100));

        // load and decode buffer
        let file = std::fs::File::open("sample.wav").unwrap();
        let audio_buffer = decode_audio_data(file);

        let mut src = context.create_buffer_source();
        src.set_buffer(&audio_buffer);
        src.connect(&context.destination());
        src.start_at(context.current_time());
        src.stop_at(context.current_time() + 128.);

        let res = context.start_rendering();

        // println!("buffer duration: {:?}", audio_buffer.duration());
        // println!("context sample rate: {:?}", context.sample_rate());

        // left
        assert_float_eq!(
            res.channel_data(0).as_slice(),
            audio_buffer.get_slice(0, 0, 128),
            abs_all <= 0.
        );

        // // right
        assert_float_eq!(
            res.channel_data(1).as_slice(),
            audio_buffer.get_slice(1, 0, 128),
            abs_all <= 0.
        );
    }
}
