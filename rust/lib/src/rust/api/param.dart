// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.36.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'analysis.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// The type `AudioParamDescriptor` is not used by any `pub` functions, thus it is ignored.
// The type `AudioParamEvent` is not used by any `pub` functions, thus it is ignored.
// The type `AudioParamEventTimeline` is not used by any `pub` functions, thus it is ignored.
// The type `AudioParamEventType` is not used by any `pub` functions, thus it is ignored.
// The type `AudioParamInner` is not used by any `pub` functions, thus it is ignored.
// The type `AudioParamProcessor` is not used by any `pub` functions, thus it is ignored.
// The type `BlockInfos` is not used by any `pub` functions, thus it is ignored.

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>
@sealed
class AudioParam extends RustOpaque {
  AudioParam.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  AudioParam.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_AudioParam,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_AudioParam,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_AudioParamPtr,
  );

  /// Current value of the automation rate of the AudioParam
  Future<AutomationRate> automationRate({dynamic hint}) => RustLib.instance.api
      .crateApiParamAudioParamAutomationRate(that: this, hint: hint);

  /// Cancels all scheduled parameter changes with times greater than or equal
  /// to `cancel_time` and the automation value that would have happened at
  /// that time is then propagated for all future time.
  ///
  /// # Panics
  ///
  /// Will panic if `cancel_time` is negative
  Future<Self> cancelAndHoldAtTime(
          {required double cancelTime, dynamic hint}) =>
      RustLib.instance.api.crateApiParamAudioParamCancelAndHoldAtTime(
          that: this, cancelTime: cancelTime, hint: hint);

  /// Cancels all scheduled parameter changes with times greater than or equal
  /// to `cancel_time`.
  ///
  /// # Panics
  ///
  /// Will panic if `cancel_time` is negative
  Future<Self> cancelScheduledValues(
          {required double cancelTime, dynamic hint}) =>
      RustLib.instance.api.crateApiParamAudioParamCancelScheduledValues(
          that: this, cancelTime: cancelTime, hint: hint);

  Future<double> defaultValue({dynamic hint}) => RustLib.instance.api
      .crateApiParamAudioParamDefaultValue(that: this, hint: hint);

  /// Schedules an exponential continuous change in parameter value from the
  /// previous scheduled parameter value to the given value.
  ///
  /// # Panics
  ///
  /// Will panic if:
  /// - `value` is zero
  /// - `end_time` is negative
  Future<Self> exponentialRampToValueAtTime(
          {required double value, required double endTime, dynamic hint}) =>
      RustLib.instance.api.crateApiParamAudioParamExponentialRampToValueAtTime(
          that: this, value: value, endTime: endTime, hint: hint);

  /// Schedules a linear continuous change in parameter value from the
  /// previous scheduled parameter value to the given value.
  ///
  /// # Panics
  ///
  /// Will panic if `end_time` is negative
  Future<Self> linearRampToValueAtTime(
          {required double value, required double endTime, dynamic hint}) =>
      RustLib.instance.api.crateApiParamAudioParamLinearRampToValueAtTime(
          that: this, value: value, endTime: endTime, hint: hint);

  Future<double> maxValue({dynamic hint}) => RustLib.instance.api
      .crateApiParamAudioParamMaxValue(that: this, hint: hint);

  Future<double> minValue({dynamic hint}) => RustLib.instance.api
      .crateApiParamAudioParamMinValue(that: this, hint: hint);

  /// Update the current value of the automation rate of the AudioParam
  ///
  /// # Panics
  ///
  /// Some nodes have automation rate constraints and may panic when updating the value.
  Future<void> setAutomationRate(
          {required AutomationRate value, dynamic hint}) =>
      RustLib.instance.api.crateApiParamAudioParamSetAutomationRate(
          that: this, value: value, hint: hint);

  /// Start exponentially approaching the target value at the given time with
  /// a rate having the given time constant.
  ///
  /// # Panics
  ///
  /// Will panic if:
  /// - `start_time` is negative
  /// - `time_constant` is negative
  Future<Self> setTargetAtTime(
          {required double value,
          required double startTime,
          required double timeConstant,
          dynamic hint}) =>
      RustLib.instance.api.crateApiParamAudioParamSetTargetAtTime(
          that: this,
          value: value,
          startTime: startTime,
          timeConstant: timeConstant,
          hint: hint);

  /// Set the value of the `AudioParam`.
  ///
  /// Is equivalent to calling the `set_value_at_time` method with the current
  /// AudioContext's currentTime
  Future<Self> setValue({required double value, dynamic hint}) => RustLib
      .instance.api
      .crateApiParamAudioParamSetValue(that: this, value: value, hint: hint);

  /// Schedules a parameter value change at the given time.
  ///
  /// # Panics
  ///
  /// Will panic if `start_time` is negative
  Future<Self> setValueAtTime(
          {required double value, required double startTime, dynamic hint}) =>
      RustLib.instance.api.crateApiParamAudioParamSetValueAtTime(
          that: this, value: value, startTime: startTime, hint: hint);

  /// Sets an array of arbitrary parameter values starting at the given time
  /// for the given duration.
  ///
  /// # Panics
  ///
  /// Will panic if:
  /// - `value` length is less than 2
  /// - `start_time` is negative
  /// - `duration` is negative or equal to zero
  Future<Self> setValueCurveAtTime(
          {required F32 values,
          required double startTime,
          required double duration,
          dynamic hint}) =>
      RustLib.instance.api.crateApiParamAudioParamSetValueCurveAtTime(
          that: this,
          values: values,
          startTime: startTime,
          duration: duration,
          hint: hint);

  /// Retrieve the current value of the `AudioParam`.
  Future<double> value({dynamic hint}) =>
      RustLib.instance.api.crateApiParamAudioParamValue(that: this, hint: hint);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Self>>
@sealed
class Self extends RustOpaque {
  Self.dcoDecode(List<dynamic> wire) : super.dcoDecode(wire, _kStaticData);

  Self.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Self,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Self,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_SelfPtr,
  );
}

/// Precision of AudioParam value calculation per render quantum
enum AutomationRate {
  /// Audio Rate - sampled for each sample-frame of the block
  a,

  /// Control Rate - sampled at the time of the very first sample-frame,
  /// then used for the entire block
  k,
  ;
}
