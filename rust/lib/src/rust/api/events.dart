// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.36.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'buffer.dart';
import 'capacity.dart';
import 'context/context.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// The type `EventPayload` is not used by any `pub` functions, thus it is ignored.

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioProcessingEvent>>
@sealed
class AudioProcessingEvent extends RustOpaque {
  AudioProcessingEvent.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  AudioProcessingEvent.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_AudioProcessingEvent,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_AudioProcessingEvent,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_AudioProcessingEventPtr,
  );

  AudioBuffer get inputBuffer =>
      RustLib.instance.api.crateApiEventsAudioProcessingEventGetInputBuffer(
        that: this,
      );

  AudioBuffer get outputBuffer =>
      RustLib.instance.api.crateApiEventsAudioProcessingEventGetOutputBuffer(
        that: this,
      );

  double get playbackTime =>
      RustLib.instance.api.crateApiEventsAudioProcessingEventGetPlaybackTime(
        that: this,
      );

  void set inputBuffer(AudioBuffer inputBuffer) =>
      RustLib.instance.api.crateApiEventsAudioProcessingEventSetInputBuffer(
          that: this, inputBuffer: inputBuffer);

  void set outputBuffer(AudioBuffer outputBuffer) =>
      RustLib.instance.api.crateApiEventsAudioProcessingEventSetOutputBuffer(
          that: this, outputBuffer: outputBuffer);

  void set playbackTime(double playbackTime) =>
      RustLib.instance.api.crateApiEventsAudioProcessingEventSetPlaybackTime(
          that: this, playbackTime: playbackTime);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box < dyn Any + Send + 'static >>>
@sealed
class BoxAny extends RustOpaque {
  BoxAny.dcoDecode(List<dynamic> wire) : super.dcoDecode(wire, _kStaticData);

  BoxAny.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_BoxAny,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_BoxAny,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_BoxAnyPtr,
  );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box < dyn Send >>>
@sealed
class BoxSend extends RustOpaque {
  BoxSend.dcoDecode(List<dynamic> wire) : super.dcoDecode(wire, _kStaticData);

  BoxSend.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_BoxSend,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_BoxSend,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_BoxSendPtr,
  );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ErrorEvent>>
@sealed
class ErrorEvent extends RustOpaque {
  ErrorEvent.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  ErrorEvent.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ErrorEvent,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ErrorEvent,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ErrorEventPtr,
  );

  BoxSend get error => RustLib.instance.api.crateApiEventsErrorEventGetError(
        that: this,
      );

  Event get event => RustLib.instance.api.crateApiEventsErrorEventGetEvent(
        that: this,
      );

  String get message => RustLib.instance.api.crateApiEventsErrorEventGetMessage(
        that: this,
      );

  void set error(BoxSend error) => RustLib.instance.api
      .crateApiEventsErrorEventSetError(that: this, error: error);

  void set event(Event event) => RustLib.instance.api
      .crateApiEventsErrorEventSetEvent(that: this, event: event);

  void set message(String message) => RustLib.instance.api
      .crateApiEventsErrorEventSetMessage(that: this, message: message);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>>
@sealed
class Event extends RustOpaque {
  Event.dcoDecode(List<dynamic> wire) : super.dcoDecode(wire, _kStaticData);

  Event.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Event,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Event,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_EventPtr,
  );

  Str get type => RustLib.instance.api.crateApiEventsEventGetType(
        that: this,
      );

  void set type(Str type) =>
      RustLib.instance.api.crateApiEventsEventSetType(that: this, type: type);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventDispatch>>
@sealed
class EventDispatch extends RustOpaque {
  EventDispatch.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  EventDispatch.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_EventDispatch,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_EventDispatch,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_EventDispatchPtr,
  );

  static Future<EventDispatch> audioProcessing(
          {required AudioNodeId id,
          required AudioProcessingEvent value,
          dynamic hint}) =>
      RustLib.instance.api.crateApiEventsEventDispatchAudioProcessing(
          id: id, value: value, hint: hint);

  static Future<EventDispatch> complete(
          {required AudioBuffer buffer, dynamic hint}) =>
      RustLib.instance.api
          .crateApiEventsEventDispatchComplete(buffer: buffer, hint: hint);

  static Future<EventDispatch> diagnostics(
          {required List<int> value, dynamic hint}) =>
      RustLib.instance.api
          .crateApiEventsEventDispatchDiagnostics(value: value, hint: hint);

  static Future<EventDispatch> ended({required AudioNodeId id, dynamic hint}) =>
      RustLib.instance.api.crateApiEventsEventDispatchEnded(id: id, hint: hint);

  static Future<EventDispatch> message(
          {required AudioNodeId id, required BoxAny value, dynamic hint}) =>
      RustLib.instance.api
          .crateApiEventsEventDispatchMessage(id: id, value: value, hint: hint);

  static Future<EventDispatch> processorError(
          {required AudioNodeId id, required ErrorEvent value, dynamic hint}) =>
      RustLib.instance.api.crateApiEventsEventDispatchProcessorError(
          id: id, value: value, hint: hint);

  static Future<EventDispatch> renderCapacity(
          {required AudioRenderCapacityEvent value, dynamic hint}) =>
      RustLib.instance.api
          .crateApiEventsEventDispatchRenderCapacity(value: value, hint: hint);

  static Future<EventDispatch> sinkChange({dynamic hint}) =>
      RustLib.instance.api.crateApiEventsEventDispatchSinkChange(hint: hint);

  static Future<EventDispatch> stateChange(
          {required AudioContextState state, dynamic hint}) =>
      RustLib.instance.api
          .crateApiEventsEventDispatchStateChange(state: state, hint: hint);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventHandler>>
@sealed
class EventHandler extends RustOpaque {
  EventHandler.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  EventHandler.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_EventHandler,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_EventHandler,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_EventHandlerPtr,
  );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventLoop>>
@sealed
class EventLoop extends RustOpaque {
  EventLoop.dcoDecode(List<dynamic> wire) : super.dcoDecode(wire, _kStaticData);

  EventLoop.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_EventLoop,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_EventLoop,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_EventLoopPtr,
  );

  Future<void> clearHandler({required EventType event, dynamic hint}) =>
      RustLib.instance.api.crateApiEventsEventLoopClearHandler(
          that: this, event: event, hint: hint);

  Future<bool> handlePendingEvents({dynamic hint}) => RustLib.instance.api
      .crateApiEventsEventLoopHandlePendingEvents(that: this, hint: hint);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<EventLoop> newInstance(
          {required ReceiverEventDispatch eventRecv, dynamic hint}) =>
      RustLib.instance.api
          .crateApiEventsEventLoopNew(eventRecv: eventRecv, hint: hint);

  Future<void> runInThread({dynamic hint}) => RustLib.instance.api
      .crateApiEventsEventLoopRunInThread(that: this, hint: hint);

  Future<void> setHandler(
          {required EventType event,
          required EventHandler callback,
          dynamic hint}) =>
      RustLib.instance.api.crateApiEventsEventLoopSetHandler(
          that: this, event: event, callback: callback, hint: hint);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventType>>
@sealed
class EventType extends RustOpaque {
  EventType.dcoDecode(List<dynamic> wire) : super.dcoDecode(wire, _kStaticData);

  EventType.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_EventType,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_EventType,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_EventTypePtr,
  );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioCompletionEvent>>
@sealed
class OfflineAudioCompletionEvent extends RustOpaque {
  OfflineAudioCompletionEvent.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  OfflineAudioCompletionEvent.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib.instance.api
        .rust_arc_increment_strong_count_OfflineAudioCompletionEvent,
    rustArcDecrementStrongCount: RustLib.instance.api
        .rust_arc_decrement_strong_count_OfflineAudioCompletionEvent,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_OfflineAudioCompletionEventPtr,
  );

  Event get event =>
      RustLib.instance.api.crateApiEventsOfflineAudioCompletionEventGetEvent(
        that: this,
      );

  AudioBuffer get renderedBuffer => RustLib.instance.api
          .crateApiEventsOfflineAudioCompletionEventGetRenderedBuffer(
        that: this,
      );

  void set event(Event event) =>
      RustLib.instance.api.crateApiEventsOfflineAudioCompletionEventSetEvent(
          that: this, event: event);

  void set renderedBuffer(AudioBuffer renderedBuffer) => RustLib.instance.api
      .crateApiEventsOfflineAudioCompletionEventSetRenderedBuffer(
          that: this, renderedBuffer: renderedBuffer);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Receiver < EventDispatch >>>
@sealed
class ReceiverEventDispatch extends RustOpaque {
  ReceiverEventDispatch.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  ReceiverEventDispatch.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_ReceiverEventDispatch,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_ReceiverEventDispatch,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_ReceiverEventDispatchPtr,
  );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<& 'static str>>
@sealed
class Str extends RustOpaque {
  Str.dcoDecode(List<dynamic> wire) : super.dcoDecode(wire, _kStaticData);

  Str.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Str,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Str,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_StrPtr,
  );
}
