// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.36.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// The type `AllocInner` is not used by any `pub` functions, thus it is ignored.

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Alloc>>
@sealed
class Alloc extends RustOpaque {
  Alloc.dcoDecode(List<dynamic> wire) : super.dcoDecode(wire, _kStaticData);

  Alloc.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Alloc,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Alloc,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_AllocPtr,
  );

  Future<AudioRenderQuantumChannel> silence({dynamic hint}) =>
      RustLib.instance.api
          .crateApiRenderQuantumAllocSilence(that: this, hint: hint);

  static Future<Alloc> withCapacity({required BigInt n, dynamic hint}) =>
      RustLib.instance.api
          .crateApiRenderQuantumAllocWithCapacity(n: n, hint: hint);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderQuantum>>
@sealed
class AudioRenderQuantum extends RustOpaque {
  AudioRenderQuantum.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  AudioRenderQuantum.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_AudioRenderQuantum,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_AudioRenderQuantum,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_AudioRenderQuantumPtr,
  );

  /// Get the samples from this specific channel.
  ///
  /// # Panics
  /// Panics if the index is greater than the available number of channels
  Future<AudioRenderQuantumChannel> channelData(
          {required BigInt index, dynamic hint}) =>
      RustLib.instance.api.crateApiRenderQuantumAudioRenderQuantumChannelData(
          that: this, index: index, hint: hint);

  /// Get the samples (mutable) from this specific channel.
  ///
  /// # Panics
  /// Panics if the index is greater than the available number of channels
  Future<AudioRenderQuantumChannel> channelDataMut(
          {required BigInt index, dynamic hint}) =>
      RustLib.instance.api
          .crateApiRenderQuantumAudioRenderQuantumChannelDataMut(
              that: this, index: index, hint: hint);

  /// Channel data as slice
  Future<AudioRenderQuantumChannel> channels({dynamic hint}) => RustLib
      .instance.api
      .crateApiRenderQuantumAudioRenderQuantumChannels(that: this, hint: hint);

  /// Channel data as slice (mutable)
  Future<AudioRenderQuantumChannel> channelsMut({dynamic hint}) =>
      RustLib.instance.api.crateApiRenderQuantumAudioRenderQuantumChannelsMut(
          that: this, hint: hint);

  /// `O(1)` check if this buffer is equal to the 'silence buffer'
  ///
  /// If this function returns false, it is still possible for all samples to be zero.
  Future<bool> isSilent({dynamic hint}) => RustLib.instance.api
      .crateApiRenderQuantumAudioRenderQuantumIsSilent(that: this, hint: hint);

  /// Convert this buffer to silence
  ///
  /// `O(1)` operation to convert this buffer to the 'silence buffer' which will enable some
  /// optimizations in the graph rendering.
  Future<void> makeSilent({dynamic hint}) =>
      RustLib.instance.api.crateApiRenderQuantumAudioRenderQuantumMakeSilent(
          that: this, hint: hint);

  /// Number of channels in this AudioRenderQuantum
  Future<BigInt> numberOfChannels({dynamic hint}) => RustLib.instance.api
      .crateApiRenderQuantumAudioRenderQuantumNumberOfChannels(
          that: this, hint: hint);

  /// Set number of channels in this AudioRenderQuantum
  ///
  /// Note: if the new number is higher than the previous, the new channels will be filled with
  /// garbage.
  ///
  /// # Panics
  ///
  /// This function will panic if the given number of channels is outside the [1, 32] range, 32
  /// being defined by the MAX_CHANNELS constant.
  Future<void> setNumberOfChannels({required BigInt n, dynamic hint}) =>
      RustLib.instance.api
          .crateApiRenderQuantumAudioRenderQuantumSetNumberOfChannels(
              that: this, n: n, hint: hint);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderQuantumChannel>>
@sealed
class AudioRenderQuantumChannel extends RustOpaque {
  AudioRenderQuantumChannel.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  AudioRenderQuantumChannel.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_AudioRenderQuantumChannel,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_AudioRenderQuantumChannel,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_AudioRenderQuantumChannelPtr,
  );
}
