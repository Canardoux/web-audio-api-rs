// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.36.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'events.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// The type `AudioRenderCapacityLoad` is not used by any `pub` functions, thus it is ignored.

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacity>>
@sealed
class AudioRenderCapacity extends RustOpaque {
  AudioRenderCapacity.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  AudioRenderCapacity.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_AudioRenderCapacity,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_AudioRenderCapacity,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_AudioRenderCapacityPtr,
  );

  /// Unset the EventHandler for [`AudioRenderCapacityEvent`].
  Future<void> clearOnupdate({dynamic hint}) => RustLib.instance.api
      .crateApiCapacityAudioRenderCapacityClearOnupdate(that: this, hint: hint);

  /// The EventHandler for [`AudioRenderCapacityEvent`].
  ///
  /// Only a single event handler is active at any time. Calling this method multiple times will
  /// override the previous event handler.
  Future<void> setOnupdate({required F callback, dynamic hint}) =>
      RustLib.instance.api.crateApiCapacityAudioRenderCapacitySetOnupdate(
          that: this, callback: callback, hint: hint);

  /// Start metric collection and analysis
  Future<void> start(
          {required AudioRenderCapacityOptions options, dynamic hint}) =>
      RustLib.instance.api.crateApiCapacityAudioRenderCapacityStart(
          that: this, options: options, hint: hint);

  /// Stop metric collection and analysis
  Future<void> stop({dynamic hint}) => RustLib.instance.api
      .crateApiCapacityAudioRenderCapacityStop(that: this, hint: hint);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<F>>
@sealed
class F extends RustOpaque {
  F.dcoDecode(List<dynamic> wire) : super.dcoDecode(wire, _kStaticData);

  F.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_F,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_F,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_FPtr,
  );
}

/// Performance metrics of the rendering thread
class AudioRenderCapacityEvent {
  /// The start time of the data collection period in terms of the associated AudioContext's currentTime
  final double timestamp;

  /// An average of collected load values over the given update interval
  final double averageLoad;

  /// A maximum value from collected load values over the given update interval.
  final double peakLoad;

  /// A ratio between the number of buffer underruns and the total number of system-level audio callbacks over the given update interval.
  final double underrunRatio;

  /// Inherits from this base Event
  final Event event;

  const AudioRenderCapacityEvent({
    required this.timestamp,
    required this.averageLoad,
    required this.peakLoad,
    required this.underrunRatio,
    required this.event,
  });

  @override
  int get hashCode =>
      timestamp.hashCode ^
      averageLoad.hashCode ^
      peakLoad.hashCode ^
      underrunRatio.hashCode ^
      event.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AudioRenderCapacityEvent &&
          runtimeType == other.runtimeType &&
          timestamp == other.timestamp &&
          averageLoad == other.averageLoad &&
          peakLoad == other.peakLoad &&
          underrunRatio == other.underrunRatio &&
          event == other.event;
}

/// Options for constructing an `AudioRenderCapacity`
class AudioRenderCapacityOptions {
  /// An update interval (in seconds) for dispatching [`AudioRenderCapacityEvent`]s
  final double updateInterval;

  const AudioRenderCapacityOptions({
    required this.updateInterval,
  });

  @override
  int get hashCode => updateInterval.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AudioRenderCapacityOptions &&
          runtimeType == other.runtimeType &&
          updateInterval == other.updateInterval;
}
