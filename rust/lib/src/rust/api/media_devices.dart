// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.36.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// The type `DeviceId` is not used by any `pub` functions, thus it is ignored.
// The type `MediaStreamConstraints` is not used by any `pub` functions, thus it is ignored.
// The type `MediaTrackConstraints` is not used by any `pub` functions, thus it is ignored.

/// List the available media output devices, such as speakers, headsets, loopbacks, etc
///
/// The media device_id can be used to specify the [`sink_id` of the `AudioContext`](crate::api::context::AudioContextOptions::sink_id)
///
/// ```no_run
/// use web_audio_api::media_devices::{enumerate_devices_sync, MediaDeviceInfoKind};
///
/// let devices = enumerate_devices_sync();
/// assert_eq!(devices[0].device_id(), "1");
/// assert_eq!(devices[0].group_id(), None);
/// assert_eq!(devices[0].kind(), MediaDeviceInfoKind::AudioOutput);
/// assert_eq!(devices[0].label(), "Macbook Pro Builtin Speakers");
/// ```
Future<List<MediaDeviceInfo>> enumerateDevicesSync({dynamic hint}) =>
    RustLib.instance.api.crateApiMediaDevicesEnumerateDevicesSync(hint: hint);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaDeviceInfo>>
@sealed
class MediaDeviceInfo extends RustOpaque {
  MediaDeviceInfo.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  MediaDeviceInfo.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_MediaDeviceInfo,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_MediaDeviceInfo,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_MediaDeviceInfoPtr,
  );

  /// Identifier for the represented device
  ///
  /// The current implementation is not stable across sessions so you should not persist this
  /// value
  Future<Str> deviceId({dynamic hint}) => RustLib.instance.api
      .crateApiMediaDevicesMediaDeviceInfoDeviceId(that: this, hint: hint);

  /// Two devices have the same group identifier if they belong to the same physical device
  Future<Str?> groupId({dynamic hint}) => RustLib.instance.api
      .crateApiMediaDevicesMediaDeviceInfoGroupId(that: this, hint: hint);

  /// Enumerated value that is either "videoinput", "audioinput" or "audiooutput".
  Future<MediaDeviceInfoKind> kind({dynamic hint}) => RustLib.instance.api
      .crateApiMediaDevicesMediaDeviceInfoKind(that: this, hint: hint);

  /// Friendly label describing this device
  Future<Str> label({dynamic hint}) => RustLib.instance.api
      .crateApiMediaDevicesMediaDeviceInfoLabel(that: this, hint: hint);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<str>>
@sealed
class Str extends RustOpaque {
  Str.dcoDecode(List<dynamic> wire) : super.dcoDecode(wire, _kStaticData);

  Str.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Str,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Str,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_StrPtr,
  );
}

/// Describes input/output type of a media device
enum MediaDeviceInfoKind {
  videoInput,
  audioInput,
  audioOutput,
  ;
}
