// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.36.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'analysis.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBuffer>>
@sealed
class AudioBuffer extends RustOpaque {
  AudioBuffer.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  AudioBuffer.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_AudioBuffer,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_AudioBuffer,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_AudioBufferPtr,
  );

  /// Copy data from a given channel to the given `Vec`
  ///
  /// # Panics
  ///
  /// This function will panic if `channel_number` is greater or equal than
  /// `AudioBuffer::number_of_channels()`
  Future<void> copyFromChannel(
          {required F32 destination,
          required BigInt channelNumber,
          dynamic hint}) =>
      RustLib.instance.api.crateApiBufferAudioBufferCopyFromChannel(
          that: this,
          destination: destination,
          channelNumber: channelNumber,
          hint: hint);

  /// Copy data from a given channel to the given `Vec` starting at `offset`
  ///
  /// # Panics
  ///
  /// This function will panic if:
  /// - the given channel number is greater than or equal to the given number of channels.
  Future<void> copyFromChannelWithOffset(
          {required F32 destination,
          required BigInt channelNumber,
          required BigInt offset,
          dynamic hint}) =>
      RustLib.instance.api.crateApiBufferAudioBufferCopyFromChannelWithOffset(
          that: this,
          destination: destination,
          channelNumber: channelNumber,
          offset: offset,
          hint: hint);

  /// Copy data from a given source to the given channel.
  ///
  /// # Panics
  ///
  /// This function will panic if:
  /// - the given channel number is greater than or equal to the given number of channels.
  Future<void> copyToChannel(
          {required F32 source, required BigInt channelNumber, dynamic hint}) =>
      RustLib.instance.api.crateApiBufferAudioBufferCopyToChannel(
          that: this, source: source, channelNumber: channelNumber, hint: hint);

  /// Copy data from a given source to the given channel starting at `offset`.
  ///
  /// # Panics
  ///
  /// This function will panic if:
  /// - the given channel number is greater than or equal to the given number of channels.
  Future<void> copyToChannelWithOffset(
          {required F32 source,
          required BigInt channelNumber,
          required BigInt offset,
          dynamic hint}) =>
      RustLib.instance.api.crateApiBufferAudioBufferCopyToChannelWithOffset(
          that: this,
          source: source,
          channelNumber: channelNumber,
          offset: offset,
          hint: hint);

  /// Duration in seconds of the `AudioBuffer`
  Future<double> duration({dynamic hint}) => RustLib.instance.api
      .crateApiBufferAudioBufferDuration(that: this, hint: hint);

  /// Convert raw samples to an AudioBuffer
  ///
  /// The outer Vec determine the channels. The inner Vecs should have the same length.
  ///
  /// # Panics
  ///
  /// This function will panic if:
  /// - the given sample rate is zero
  /// - the given number of channels defined by `samples.len()`is outside the
  ///   [1, 32] range, 32 being defined by the MAX_CHANNELS constant.
  /// - any of its items have different lengths
  static Future<AudioBuffer> from(
          {required List<Float32List> samples,
          required double sampleRate,
          dynamic hint}) =>
      RustLib.instance.api.crateApiBufferAudioBufferFrom(
          samples: samples, sampleRate: sampleRate, hint: hint);

  /// Return a read-only copy of the underlying data of the channel
  ///
  /// # Panics
  ///
  /// This function will panic if:
  /// - the given channel number is greater than or equal to the given number of channels.
  Future<F32> getChannelData({required BigInt channelNumber, dynamic hint}) =>
      RustLib.instance.api.crateApiBufferAudioBufferGetChannelData(
          that: this, channelNumber: channelNumber, hint: hint);

  /// Return a mutable slice of the underlying data of the channel
  ///
  /// # Panics
  ///
  /// This function will panic if:
  /// - the given channel number is greater than or equal to the given number of channels.
  Future<F32> getChannelDataMut(
          {required BigInt channelNumber, dynamic hint}) =>
      RustLib.instance.api.crateApiBufferAudioBufferGetChannelDataMut(
          that: this, channelNumber: channelNumber, hint: hint);

  /// Number of samples per channel in this `AudioBuffer`
  Future<BigInt> length({dynamic hint}) => RustLib.instance.api
      .crateApiBufferAudioBufferLength(that: this, hint: hint);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Allocate a silent audiobuffer with [`AudioBufferOptions`]
  ///
  /// # Panics
  ///
  /// This function will panic if:
  /// - the given sample rate is zero
  /// - the given number of channels is outside the [1, 32] range,
  /// 32 being defined by the MAX_CHANNELS constant.
  static Future<AudioBuffer> newInstance(
          {required AudioBufferOptions options, dynamic hint}) =>
      RustLib.instance.api
          .crateApiBufferAudioBufferNew(options: options, hint: hint);

  /// Number of channels in this `AudioBuffer`
  Future<BigInt> numberOfChannels({dynamic hint}) => RustLib.instance.api
      .crateApiBufferAudioBufferNumberOfChannels(that: this, hint: hint);

  /// Sample rate of this `AudioBuffer` in Hertz
  Future<double> sampleRate({dynamic hint}) => RustLib.instance.api
      .crateApiBufferAudioBufferSampleRate(that: this, hint: hint);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferOptions>>
@sealed
class AudioBufferOptions extends RustOpaque {
  AudioBufferOptions.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  AudioBufferOptions.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_AudioBufferOptions,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_AudioBufferOptions,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_AudioBufferOptionsPtr,
  );

  BigInt get length =>
      RustLib.instance.api.crateApiBufferAudioBufferOptionsGetLength(
        that: this,
      );

  BigInt get numberOfChannels =>
      RustLib.instance.api.crateApiBufferAudioBufferOptionsGetNumberOfChannels(
        that: this,
      );

  double get sampleRate =>
      RustLib.instance.api.crateApiBufferAudioBufferOptionsGetSampleRate(
        that: this,
      );

  void set length(BigInt length) => RustLib.instance.api
      .crateApiBufferAudioBufferOptionsSetLength(that: this, length: length);

  void set numberOfChannels(BigInt numberOfChannels) =>
      RustLib.instance.api.crateApiBufferAudioBufferOptionsSetNumberOfChannels(
          that: this, numberOfChannels: numberOfChannels);

  void set sampleRate(double sampleRate) =>
      RustLib.instance.api.crateApiBufferAudioBufferOptionsSetSampleRate(
          that: this, sampleRate: sampleRate);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelData>>
@sealed
class ChannelData extends RustOpaque {
  ChannelData.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  ChannelData.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ChannelData,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ChannelData,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ChannelDataPtr,
  );

  Future<F32> asMutSlice({dynamic hint}) => RustLib.instance.api
      .crateApiBufferChannelDataAsMutSlice(that: this, hint: hint);

  Future<F32> asSlice({dynamic hint}) => RustLib.instance.api
      .crateApiBufferChannelDataAsSlice(that: this, hint: hint);

  static Future<ChannelData> from({required List<double> data, dynamic hint}) =>
      RustLib.instance.api
          .crateApiBufferChannelDataFrom(data: data, hint: hint);

  Future<bool> isEmpty({dynamic hint}) => RustLib.instance.api
      .crateApiBufferChannelDataIsEmpty(that: this, hint: hint);

  Future<BigInt> len({dynamic hint}) =>
      RustLib.instance.api.crateApiBufferChannelDataLen(that: this, hint: hint);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<ChannelData> newInstance(
          {required BigInt length, dynamic hint}) =>
      RustLib.instance.api
          .crateApiBufferChannelDataNew(length: length, hint: hint);
}
