// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.36.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../capacity.dart';
import 'analyser.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// The type `ScriptProcessorRenderer` is not used by any `pub` functions, thus it is ignored.

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ScriptProcessorNode>>
@sealed
class ScriptProcessorNode extends RustOpaque {
  ScriptProcessorNode.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  ScriptProcessorNode.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_ScriptProcessorNode,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_ScriptProcessorNode,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_ScriptProcessorNodePtr,
  );

  Future<BigInt> bufferSize({dynamic hint}) => RustLib.instance.api
      .crateApiNodeScriptProcessorScriptProcessorNodeBufferSize(
          that: this, hint: hint);

  /// Unset the callback to run when the AudioProcessingEvent is dispatched
  Future<void> clearOnaudioprocess({dynamic hint}) => RustLib.instance.api
      .crateApiNodeScriptProcessorScriptProcessorNodeClearOnaudioprocess(
          that: this, hint: hint);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a `ScriptProcessorNode`
  ///
  /// # Arguments
  ///
  /// - `context` - Audio context in which the node will live
  /// - `options` - node options
  ///
  /// # Panics
  ///
  /// This function panics if:
  /// - `buffer_size` is not 256, 512, 1024, 2048, 4096, 8192, or 16384
  /// - the number of input and output channels are both zero
  /// - either of the channel counts exceed [`crate::api::MAX_CHANNELS`]
  static Future<ScriptProcessorNode> newInstance(
          {required C context,
          required ScriptProcessorOptions options,
          dynamic hint}) =>
      RustLib.instance.api.crateApiNodeScriptProcessorScriptProcessorNodeNew(
          context: context, options: options, hint: hint);

  /// Register callback to run when the AudioProcessingEvent is dispatched
  ///
  /// The event handler processes audio from the input (if any) by accessing the audio data from
  /// the inputBuffer attribute. The audio data which is the result of the processing (or the
  /// synthesized data if there are no inputs) is then placed into the outputBuffer.
  ///
  /// The output buffer is shipped back to the render thread when the AudioProcessingEvent goes
  /// out of scope, so be sure not to store it somewhere.
  ///
  /// Only a single event handler is active at any time. Calling this method multiple times will
  /// override the previous event handler.
  Future<void> setOnaudioprocess({required F callback, dynamic hint}) =>
      RustLib.instance.api
          .crateApiNodeScriptProcessorScriptProcessorNodeSetOnaudioprocess(
              that: this, callback: callback, hint: hint);
}

/// Options for constructing an [`ScriptProcessorNode`]
class ScriptProcessorOptions {
  final BigInt bufferSize;
  final BigInt numberOfInputChannels;
  final BigInt numberOfOutputChannels;

  const ScriptProcessorOptions({
    required this.bufferSize,
    required this.numberOfInputChannels,
    required this.numberOfOutputChannels,
  });

  @override
  int get hashCode =>
      bufferSize.hashCode ^
      numberOfInputChannels.hashCode ^
      numberOfOutputChannels.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ScriptProcessorOptions &&
          runtimeType == other.runtimeType &&
          bufferSize == other.bufferSize &&
          numberOfInputChannels == other.numberOfInputChannels &&
          numberOfOutputChannels == other.numberOfOutputChannels;
}
