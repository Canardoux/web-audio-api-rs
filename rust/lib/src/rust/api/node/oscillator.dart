// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.36.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../param.dart';
import '../periodic_wave.dart';
import 'analyser.dart';
import 'audio_node.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// The type `OscillatorRenderer` is not used by any `pub` functions, thus it is ignored.
// The type `Schedule` is not used by any `pub` functions, thus it is ignored.

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OscillatorNode>>
@sealed
class OscillatorNode extends RustOpaque {
  OscillatorNode.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  OscillatorNode.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_OscillatorNode,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_OscillatorNode,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_OscillatorNodePtr,
  );

  /// A-rate [`AudioParam`] that defines a transposition according to the
  /// frequency, expressed in cents.
  ///
  /// see <https://en.wikipedia.org/wiki/Cent_(music)>
  ///
  /// The final frequency is calculated as follow: frequency * 2^(detune/1200)
  Future<AudioParam> detune({dynamic hint}) => RustLib.instance.api
      .crateApiNodeOscillatorOscillatorNodeDetune(that: this, hint: hint);

  /// A-rate [`AudioParam`] that defines the fundamental frequency of the
  /// oscillator, expressed in Hz
  ///
  /// The final frequency is calculated as follow: frequency * 2^(detune/1200)
  Future<AudioParam> frequency({dynamic hint}) => RustLib.instance.api
      .crateApiNodeOscillatorOscillatorNodeFrequency(that: this, hint: hint);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Returns an `OscillatorNode`
  ///
  /// # Arguments:
  ///
  /// * `context` - The `AudioContext`
  /// * `options` - The OscillatorOptions
  static Future<OscillatorNode> newInstance(
          {required C context,
          required OscillatorOptions options,
          dynamic hint}) =>
      RustLib.instance.api.crateApiNodeOscillatorOscillatorNodeNew(
          context: context, options: options, hint: hint);

  /// Sets a `PeriodicWave` which describes a waveform to be used by the oscillator.
  ///
  /// Calling this sets the oscillator type to `custom`, once set to `custom`
  /// the oscillator cannot be reverted back to a standard waveform.
  Future<void> setPeriodicWave(
          {required PeriodicWave periodicWave, dynamic hint}) =>
      RustLib.instance.api.crateApiNodeOscillatorOscillatorNodeSetPeriodicWave(
          that: this, periodicWave: periodicWave, hint: hint);

  /// Set the oscillator type
  ///
  /// # Arguments
  ///
  /// * `type_` - oscillator type (sine, square, triangle, sawtooth)
  ///
  /// # Panics
  ///
  /// if `type_` is `OscillatorType::Custom`
  Future<void> setType({required OscillatorType type, dynamic hint}) =>
      RustLib.instance.api.crateApiNodeOscillatorOscillatorNodeSetType(
          that: this, type: type, hint: hint);

  /// Returns the oscillator type
  Future<OscillatorType> type({dynamic hint}) => RustLib.instance.api
      .crateApiNodeOscillatorOscillatorNodeType(that: this, hint: hint);
}

/// Options for constructing an [`OscillatorNode`]
class OscillatorOptions {
  /// The shape of the periodic waveform
  final OscillatorType type;

  /// The frequency of the fundamental frequency.
  final double frequency;

  /// A detuning value (in cents) which will offset the frequency by the given amount.
  final double detune;

  /// Optional custom waveform, if specified (set `type` to "custom")
  final PeriodicWave? periodicWave;

  /// channel config options
  final AudioNodeOptions audioNodeOptions;

  const OscillatorOptions({
    required this.type,
    required this.frequency,
    required this.detune,
    this.periodicWave,
    required this.audioNodeOptions,
  });

  @override
  int get hashCode =>
      type.hashCode ^
      frequency.hashCode ^
      detune.hashCode ^
      periodicWave.hashCode ^
      audioNodeOptions.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OscillatorOptions &&
          runtimeType == other.runtimeType &&
          type == other.type &&
          frequency == other.frequency &&
          detune == other.detune &&
          periodicWave == other.periodicWave &&
          audioNodeOptions == other.audioNodeOptions;
}

/// Type of the waveform rendered by an `OscillatorNode`
enum OscillatorType {
  /// Sine wave
  sine,

  /// Square wave
  square,

  /// Sawtooth wave
  sawtooth,

  /// Triangle wave
  triangle,

  /// type used when periodic_wave is specified
  custom,
  ;
}
