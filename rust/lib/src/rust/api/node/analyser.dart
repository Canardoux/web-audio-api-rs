// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.36.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../analysis.dart';
import 'audio_node.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// The type `AnalyserRenderer` is not used by any `pub` functions, thus it is ignored.

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserNode>>
@sealed
class AnalyserNode extends RustOpaque {
  AnalyserNode.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  AnalyserNode.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_AnalyserNode,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_AnalyserNode,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_AnalyserNodePtr,
  );

  /// The size of the FFT used for frequency-domain analysis (in sample-frames)
  ///
  /// # Panics
  ///
  /// This method may panic if the lock to the inner analyser is poisoned
  Future<BigInt> fftSize({dynamic hint}) => RustLib.instance.api
      .crateApiNodeAnalyserAnalyserNodeFftSize(that: this, hint: hint);

  /// Number of bins in the FFT results, is half the FFT size
  ///
  /// # Panics
  ///
  /// This method may panic if the lock to the inner analyser is poisoned
  Future<BigInt> frequencyBinCount({dynamic hint}) =>
      RustLib.instance.api.crateApiNodeAnalyserAnalyserNodeFrequencyBinCount(
          that: this, hint: hint);

  /// Copy the current frequency data scaled between min_decibels and
  /// max_decibels into the provided buffer
  ///
  /// # Panics
  ///
  /// This method may panic if the lock to the inner analyser is poisoned
  Future<void> getByteFrequencyData({required U8 buffer, dynamic hint}) =>
      RustLib.instance.api.crateApiNodeAnalyserAnalyserNodeGetByteFrequencyData(
          that: this, buffer: buffer, hint: hint);

  /// Copy the current time domain data as u8 values into the provided buffer
  ///
  /// # Panics
  ///
  /// This method may panic if the lock to the inner analyser is poisoned
  Future<void> getByteTimeDomainData({required U8 buffer, dynamic hint}) =>
      RustLib.instance.api
          .crateApiNodeAnalyserAnalyserNodeGetByteTimeDomainData(
              that: this, buffer: buffer, hint: hint);

  /// Copy the current frequency data into the provided buffer
  ///
  /// # Panics
  ///
  /// This method may panic if the lock to the inner analyser is poisoned
  Future<void> getFloatFrequencyData({required F32 buffer, dynamic hint}) =>
      RustLib.instance.api
          .crateApiNodeAnalyserAnalyserNodeGetFloatFrequencyData(
              that: this, buffer: buffer, hint: hint);

  /// Copy the current time domain data as f32 values into the provided buffer
  ///
  /// # Panics
  ///
  /// This method may panic if the lock to the inner analyser is poisoned
  Future<void> getFloatTimeDomainData({required F32 buffer, dynamic hint}) =>
      RustLib.instance.api
          .crateApiNodeAnalyserAnalyserNodeGetFloatTimeDomainData(
              that: this, buffer: buffer, hint: hint);

  /// Maximum power value in the scaling range for the FFT analysis data for
  /// conversion to unsigned byte values. The default value is -30.
  ///
  /// # Panics
  ///
  /// This method may panic if the lock to the inner analyser is poisoned
  Future<double> maxDecibels({dynamic hint}) => RustLib.instance.api
      .crateApiNodeAnalyserAnalyserNodeMaxDecibels(that: this, hint: hint);

  /// Minimum power value in the scaling range for the FFT analysis data for
  /// conversion to unsigned byte values. The default value is -100.
  ///
  /// # Panics
  ///
  /// This method may panic if the lock to the inner analyser is poisoned
  Future<double> minDecibels({dynamic hint}) => RustLib.instance.api
      .crateApiNodeAnalyserAnalyserNodeMinDecibels(that: this, hint: hint);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<AnalyserNode> newInstance(
          {required C context,
          required AnalyserOptions options,
          dynamic hint}) =>
      RustLib.instance.api.crateApiNodeAnalyserAnalyserNodeNew(
          context: context, options: options, hint: hint);

  /// Set FFT size
  ///
  /// # Panics
  ///
  /// This function panics if fft_size is not a power of two or not in the range [32, 32768]
  Future<void> setFftSize({required BigInt fftSize, dynamic hint}) =>
      RustLib.instance.api.crateApiNodeAnalyserAnalyserNodeSetFftSize(
          that: this, fftSize: fftSize, hint: hint);

  /// Set max decibels
  ///
  /// # Panics
  ///
  /// This function panics if the value is set to a value less than or equal
  /// to min decibels.
  Future<void> setMaxDecibels({required double value, dynamic hint}) =>
      RustLib.instance.api.crateApiNodeAnalyserAnalyserNodeSetMaxDecibels(
          that: this, value: value, hint: hint);

  /// Set min decibels
  ///
  /// # Panics
  ///
  /// This function panics if the value is set to a value more than or equal
  /// to max decibels.
  Future<void> setMinDecibels({required double value, dynamic hint}) =>
      RustLib.instance.api.crateApiNodeAnalyserAnalyserNodeSetMinDecibels(
          that: this, value: value, hint: hint);

  /// Set smoothing time constant
  ///
  /// # Panics
  ///
  /// This function panics if the value is set to a value less than 0 or more than 1.
  Future<void> setSmoothingTimeConstant(
          {required double value, dynamic hint}) =>
      RustLib.instance.api
          .crateApiNodeAnalyserAnalyserNodeSetSmoothingTimeConstant(
              that: this, value: value, hint: hint);

  /// Time averaging parameter with the last analysis frame.
  /// A value from 0 -> 1 where 0 represents no time averaging with the last
  /// analysis frame. The default value is 0.8.
  ///
  /// # Panics
  ///
  /// This method may panic if the lock to the inner analyser is poisoned
  Future<double> smoothingTimeConstant({dynamic hint}) => RustLib.instance.api
      .crateApiNodeAnalyserAnalyserNodeSmoothingTimeConstant(
          that: this, hint: hint);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>>
@sealed
class C extends RustOpaque {
  C.dcoDecode(List<dynamic> wire) : super.dcoDecode(wire, _kStaticData);

  C.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_C,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_C,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_CPtr,
  );
}

/// Options for constructing an [`AnalyserNode`]
class AnalyserOptions {
  final BigInt fftSize;
  final double maxDecibels;
  final double minDecibels;
  final double smoothingTimeConstant;
  final AudioNodeOptions audioNodeOptions;

  const AnalyserOptions({
    required this.fftSize,
    required this.maxDecibels,
    required this.minDecibels,
    required this.smoothingTimeConstant,
    required this.audioNodeOptions,
  });

  @override
  int get hashCode =>
      fftSize.hashCode ^
      maxDecibels.hashCode ^
      minDecibels.hashCode ^
      smoothingTimeConstant.hashCode ^
      audioNodeOptions.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AnalyserOptions &&
          runtimeType == other.runtimeType &&
          fftSize == other.fftSize &&
          maxDecibels == other.maxDecibels &&
          minDecibels == other.minDecibels &&
          smoothingTimeConstant == other.smoothingTimeConstant &&
          audioNodeOptions == other.audioNodeOptions;
}
