// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.36.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../analysis.dart';
import 'analyser.dart';
import 'audio_node.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// The type `RendererConfig` is not used by any `pub` functions, thus it is ignored.
// The type `ResamplerConfig` is not used by any `pub` functions, thus it is ignored.
// The type `WaveShaperRenderer` is not used by any `pub` functions, thus it is ignored.

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WaveShaperNode>>
@sealed
class WaveShaperNode extends RustOpaque {
  WaveShaperNode.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  WaveShaperNode.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_WaveShaperNode,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_WaveShaperNode,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_WaveShaperNodePtr,
  );

  /// Returns the distortion curve
  Future<F32?> curve({dynamic hint}) => RustLib.instance.api
      .crateApiNodeWaveshaperWaveShaperNodeCurve(that: this, hint: hint);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// returns a `WaveShaperNode` instance
  ///
  /// # Arguments
  ///
  /// * `context` - audio context in which the audio node will live.
  /// * `options` - waveshaper options
  static Future<WaveShaperNode> newInstance(
          {required C context,
          required WaveShaperOptions options,
          dynamic hint}) =>
      RustLib.instance.api.crateApiNodeWaveshaperWaveShaperNodeNew(
          context: context, options: options, hint: hint);

  /// Returns the `oversample` faactor of this node
  Future<OverSampleType> oversample({dynamic hint}) => RustLib.instance.api
      .crateApiNodeWaveshaperWaveShaperNodeOversample(that: this, hint: hint);

  /// Set the distortion `curve` of this node
  ///
  /// # Arguments
  ///
  /// * `curve` - the desired distortion `curve`
  ///
  /// # Panics
  ///
  /// Panics if a curve has already been given to the source (though `new` or through
  /// `set_curve`)
  Future<void> setCurve({required List<double> curve, dynamic hint}) =>
      RustLib.instance.api.crateApiNodeWaveshaperWaveShaperNodeSetCurve(
          that: this, curve: curve, hint: hint);

  /// set the `oversample` factor of this node
  ///
  /// # Arguments
  ///
  /// * `oversample` - the desired `OversampleType` variant
  Future<void> setOversample(
          {required OverSampleType oversample, dynamic hint}) =>
      RustLib.instance.api.crateApiNodeWaveshaperWaveShaperNodeSetOversample(
          that: this, oversample: oversample, hint: hint);
}

/// enumerates the oversampling rate available for `WaveShaperNode`
enum OverSampleType {
  /// No oversampling is applied
  none,

  /// Oversampled by a factor of 2
  x2,

  /// Oversampled by a factor of 4
  x4,
  ;
}

/// `WaveShaperNode` options
class WaveShaperOptions {
  /// The distortion curve
  final Float32List? curve;

  /// Oversampling rate - default to `None`
  final OverSampleType oversample;

  /// audio node options
  final AudioNodeOptions audioNodeOptions;

  const WaveShaperOptions({
    this.curve,
    required this.oversample,
    required this.audioNodeOptions,
  });

  @override
  int get hashCode =>
      curve.hashCode ^ oversample.hashCode ^ audioNodeOptions.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WaveShaperOptions &&
          runtimeType == other.runtimeType &&
          curve == other.curve &&
          oversample == other.oversample &&
          audioNodeOptions == other.audioNodeOptions;
}
