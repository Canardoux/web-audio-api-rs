// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.36.

#![allow(
non_camel_case_types,
unused,
non_snake_case,
clippy::needless_return,
clippy::redundant_closure_call,
clippy::redundant_closure,
clippy::useless_conversion,
clippy::unit_arg,
clippy::unused_unit,
clippy::double_parens,
clippy::let_and_return,
clippy::too_many_arguments,
clippy::match_single_binding,
clippy::clone_on_copy,
clippy::let_unit_value
)]

// Section: imports

use crate::api::api::*;
use crate::api::context::*;
use crate::api::context::offline::*;
use crate::api::context::concrete_base::*;
use crate::api::media_element::*;
use crate::api::message_port::*;
use crate::api::buffer::*;
use crate::api::context::online::*;
use crate::api::decoding::*;
use crate::api::analysis::*;
use crate::api::resampling::*;
use crate::api::param::*;
use crate::api::spatial::*;
use crate::api::periodic_wave::*;
use crate::api::message::*;use flutter_rust_bridge::{Handler, IntoIntoDart};
use flutter_rust_bridge::for_generated::transform_result_dco;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, WriteBytesExt, ReadBytesExt};

// Section: boilerplate


                flutter_rust_bridge::frb_generated_boilerplate!(
                    default_stream_sink_codec = SseCodec,
                    default_rust_opaque = RustOpaqueMoi,
                    default_rust_auto_opaque = RustAutoOpaqueMoi,
                );
                pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.0.0-dev.36";
                pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = -578903499;
            

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__analysis__AnalyserRingBuffer_new_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AnalyserRingBuffer_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                         Result::<_,()>::Ok(crate::api::analysis::AnalyserRingBuffer::new())
                    })())
                } })
            }fn wire__crate__api__analysis__AnalyserRingBuffer_read_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AnalyserRingBuffer_read", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserRingBuffer>>>::sse_decode(&mut deserializer);
let api_dst = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>>>::sse_decode(&mut deserializer);
let api_max_len = <usize>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_dst_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_dst, 1, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
1 => api_dst_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_dst)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
let mut api_dst = api_dst_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::analysis::AnalyserRingBuffer::read(&api_that, &mut api_dst, api_max_len))
                    })())
                } })
            }fn wire__crate__api__analysis__AnalyserRingBuffer_write_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AnalyserRingBuffer_write", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserRingBuffer>>>::sse_decode(&mut deserializer);
let api_src = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_src_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_src, 1, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
1 => api_src_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_src)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
let api_src = api_src_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::analysis::AnalyserRingBuffer::write(&api_that, &api_src))
                    })())
                } })
            }fn wire__crate__api__analysis__Analyser_fft_size_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Analyser_fft_size", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::analysis::Analyser::fft_size(&api_that))
                    })())
                } })
            }fn wire__crate__api__analysis__Analyser_frequency_bin_count_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Analyser_frequency_bin_count", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::analysis::Analyser::frequency_bin_count(&api_that))
                    })())
                } })
            }fn wire__crate__api__analysis__Analyser_get_byte_frequency_data_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Analyser_get_byte_frequency_data", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>>::sse_decode(&mut deserializer);
let api_dst = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[u8]>>>::sse_decode(&mut deserializer);
let api_current_time = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_dst_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_dst, 1, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
1 => api_dst_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_dst)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
let mut api_dst = api_dst_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::analysis::Analyser::get_byte_frequency_data(&mut api_that, &mut api_dst, api_current_time))
                    })())
                } })
            }fn wire__crate__api__analysis__Analyser_get_byte_time_domain_data_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Analyser_get_byte_time_domain_data", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>>::sse_decode(&mut deserializer);
let api_dst = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[u8]>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_dst_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_dst, 1, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
1 => api_dst_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_dst)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
let mut api_dst = api_dst_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::analysis::Analyser::get_byte_time_domain_data(&api_that, &mut api_dst))
                    })())
                } })
            }fn wire__crate__api__analysis__Analyser_get_float_frequency_data_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Analyser_get_float_frequency_data", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>>::sse_decode(&mut deserializer);
let api_dst = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>>>::sse_decode(&mut deserializer);
let api_current_time = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_dst_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_dst, 1, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
1 => api_dst_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_dst)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
let mut api_dst = api_dst_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::analysis::Analyser::get_float_frequency_data(&mut api_that, &mut api_dst, api_current_time))
                    })())
                } })
            }fn wire__crate__api__analysis__Analyser_get_float_time_domain_data_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Analyser_get_float_time_domain_data", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>>::sse_decode(&mut deserializer);
let api_dst = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_dst_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_dst, 1, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
1 => api_dst_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_dst)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
let mut api_dst = api_dst_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::analysis::Analyser::get_float_time_domain_data(&api_that, &mut api_dst))
                    })())
                } })
            }fn wire__crate__api__analysis__Analyser_get_ring_buffer_clone_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Analyser_get_ring_buffer_clone", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::analysis::Analyser::get_ring_buffer_clone(&api_that))
                    })())
                } })
            }fn wire__crate__api__analysis__Analyser_max_decibels_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Analyser_max_decibels", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::analysis::Analyser::max_decibels(&api_that))
                    })())
                } })
            }fn wire__crate__api__analysis__Analyser_min_decibels_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Analyser_min_decibels", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::analysis::Analyser::min_decibels(&api_that))
                    })())
                } })
            }fn wire__crate__api__analysis__Analyser_new_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Analyser_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                         Result::<_,()>::Ok(crate::api::analysis::Analyser::new())
                    })())
                } })
            }fn wire__crate__api__analysis__Analyser_set_decibels_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Analyser_set_decibels", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>>::sse_decode(&mut deserializer);
let api_min = <f64>::sse_decode(&mut deserializer);
let api_max = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::analysis::Analyser::set_decibels(&mut api_that, api_min, api_max))
                    })())
                } })
            }fn wire__crate__api__analysis__Analyser_set_fft_size_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Analyser_set_fft_size", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>>::sse_decode(&mut deserializer);
let api_fft_size = <usize>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::analysis::Analyser::set_fft_size(&mut api_that, api_fft_size))
                    })())
                } })
            }fn wire__crate__api__analysis__Analyser_set_smoothing_time_constant_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Analyser_set_smoothing_time_constant", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>>::sse_decode(&mut deserializer);
let api_value = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::analysis::Analyser::set_smoothing_time_constant(&mut api_that, api_value))
                    })())
                } })
            }fn wire__crate__api__analysis__Analyser_smoothing_time_constant_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Analyser_smoothing_time_constant", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::analysis::Analyser::smoothing_time_constant(&api_that))
                    })())
                } })
            }fn wire__crate__api__api__AtomicF32_load_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AtomicF32_load", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AtomicF32>>>::sse_decode(&mut deserializer);
let api_ordering = <Ordering>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::api::AtomicF32::load(&api_that, api_ordering))
                    })())
                } })
            }fn wire__crate__api__api__AtomicF32_new_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AtomicF32_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_value = <f32>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                         Result::<_,()>::Ok(crate::api::api::AtomicF32::new(api_value))
                    })())
                } })
            }fn wire__crate__api__api__AtomicF32_store_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AtomicF32_store", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AtomicF32>>>::sse_decode(&mut deserializer);
let api_value = <f32>::sse_decode(&mut deserializer);
let api_ordering = <Ordering>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::api::AtomicF32::store(&api_that, api_value, api_ordering))
                    })())
                } })
            }fn wire__crate__api__api__AtomicF64_load_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AtomicF64_load", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AtomicF64>>>::sse_decode(&mut deserializer);
let api_ordering = <Ordering>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::api::AtomicF64::load(&api_that, api_ordering))
                    })())
                } })
            }fn wire__crate__api__api__AtomicF64_new_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AtomicF64_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_value = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                         Result::<_,()>::Ok(crate::api::api::AtomicF64::new(api_value))
                    })())
                } })
            }fn wire__crate__api__api__AtomicF64_store_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AtomicF64_store", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AtomicF64>>>::sse_decode(&mut deserializer);
let api_value = <f64>::sse_decode(&mut deserializer);
let api_ordering = <Ordering>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::api::AtomicF64::store(&api_that, api_value, api_ordering))
                    })())
                } })
            }fn wire__crate__api__buffer__AudioBufferOptions_get_length_impl(ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBufferOptions_get_length", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferOptions>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(api_that.length.clone())
                })()) })
            }fn wire__crate__api__buffer__AudioBufferOptions_get_number_of_channels_impl(ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBufferOptions_get_number_of_channels", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferOptions>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(api_that.number_of_channels.clone())
                })()) })
            }fn wire__crate__api__buffer__AudioBufferOptions_get_sample_rate_impl(ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBufferOptions_get_sample_rate", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferOptions>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(api_that.sample_rate.clone())
                })()) })
            }fn wire__crate__api__buffer__AudioBufferOptions_set_length_impl(ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBufferOptions_set_length", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferOptions>>>::sse_decode(&mut deserializer);
let api_length = <usize>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.length = api_length; })
                })()) })
            }fn wire__crate__api__buffer__AudioBufferOptions_set_number_of_channels_impl(ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBufferOptions_set_number_of_channels", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferOptions>>>::sse_decode(&mut deserializer);
let api_number_of_channels = <usize>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.number_of_channels = api_number_of_channels; })
                })()) })
            }fn wire__crate__api__buffer__AudioBufferOptions_set_sample_rate_impl(ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBufferOptions_set_sample_rate", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferOptions>>>::sse_decode(&mut deserializer);
let api_sample_rate = <f32>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.sample_rate = api_sample_rate; })
                })()) })
            }fn wire__crate__api__buffer__AudioBuffer_copy_from_channel_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBuffer_copy_from_channel", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBuffer>>>::sse_decode(&mut deserializer);
let api_destination = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>>>::sse_decode(&mut deserializer);
let api_channel_number = <usize>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_destination_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_destination, 1, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
1 => api_destination_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_destination)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
let mut api_destination = api_destination_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::buffer::AudioBuffer::copy_from_channel(&api_that, &mut api_destination, api_channel_number))
                    })())
                } })
            }fn wire__crate__api__buffer__AudioBuffer_copy_from_channel_with_offset_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBuffer_copy_from_channel_with_offset", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBuffer>>>::sse_decode(&mut deserializer);
let api_destination = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>>>::sse_decode(&mut deserializer);
let api_channel_number = <usize>::sse_decode(&mut deserializer);
let api_offset = <usize>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_destination_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_destination, 1, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
1 => api_destination_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_destination)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
let mut api_destination = api_destination_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::buffer::AudioBuffer::copy_from_channel_with_offset(&api_that, &mut api_destination, api_channel_number, api_offset))
                    })())
                } })
            }fn wire__crate__api__buffer__AudioBuffer_copy_to_channel_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBuffer_copy_to_channel", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBuffer>>>::sse_decode(&mut deserializer);
let api_source = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>>>::sse_decode(&mut deserializer);
let api_channel_number = <usize>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_source_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_source, 1, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
1 => api_source_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_source)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
let api_source = api_source_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::buffer::AudioBuffer::copy_to_channel(&mut api_that, &api_source, api_channel_number))
                    })())
                } })
            }fn wire__crate__api__buffer__AudioBuffer_copy_to_channel_with_offset_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBuffer_copy_to_channel_with_offset", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBuffer>>>::sse_decode(&mut deserializer);
let api_source = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>>>::sse_decode(&mut deserializer);
let api_channel_number = <usize>::sse_decode(&mut deserializer);
let api_offset = <usize>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_source_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_source, 1, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
1 => api_source_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_source)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
let api_source = api_source_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::buffer::AudioBuffer::copy_to_channel_with_offset(&mut api_that, &api_source, api_channel_number, api_offset))
                    })())
                } })
            }fn wire__crate__api__buffer__AudioBuffer_duration_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBuffer_duration", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBuffer>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::buffer::AudioBuffer::duration(&api_that))
                    })())
                } })
            }fn wire__crate__api__buffer__AudioBuffer_from_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBuffer_from", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_samples = <Vec<Vec<f32>>>::sse_decode(&mut deserializer);
let api_sample_rate = <f32>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                         Result::<_,()>::Ok(crate::api::buffer::AudioBuffer::from(api_samples, api_sample_rate))
                    })())
                } })
            }fn wire__crate__api__buffer__AudioBuffer_get_channel_data_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBuffer_get_channel_data", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBuffer>>>::sse_decode(&mut deserializer);
let api_channel_number = <usize>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::buffer::AudioBuffer::get_channel_data(&api_that, api_channel_number))
                    })())
                } })
            }fn wire__crate__api__buffer__AudioBuffer_get_channel_data_mut_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBuffer_get_channel_data_mut", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBuffer>>>::sse_decode(&mut deserializer);
let api_channel_number = <usize>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::buffer::AudioBuffer::get_channel_data_mut(&mut api_that, api_channel_number))
                    })())
                } })
            }fn wire__crate__api__buffer__AudioBuffer_length_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBuffer_length", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBuffer>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::buffer::AudioBuffer::length(&api_that))
                    })())
                } })
            }fn wire__crate__api__buffer__AudioBuffer_new_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBuffer_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_options = <AudioBufferOptions>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                         Result::<_,()>::Ok(crate::api::buffer::AudioBuffer::new(api_options))
                    })())
                } })
            }fn wire__crate__api__buffer__AudioBuffer_number_of_channels_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBuffer_number_of_channels", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBuffer>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::buffer::AudioBuffer::number_of_channels(&api_that))
                    })())
                } })
            }fn wire__crate__api__buffer__AudioBuffer_sample_rate_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBuffer_sample_rate", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBuffer>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::buffer::AudioBuffer::sample_rate(&api_that))
                    })())
                } })
            }fn wire__crate__api__buffer__ChannelData_as_mut_slice_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ChannelData_as_mut_slice", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelData>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::buffer::ChannelData::as_mut_slice(&mut api_that))
                    })())
                } })
            }fn wire__crate__api__buffer__ChannelData_as_slice_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ChannelData_as_slice", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelData>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::buffer::ChannelData::as_slice(&api_that))
                    })())
                } })
            }fn wire__crate__api__buffer__ChannelData_from_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ChannelData_from", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <Vec<f32>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                         Result::<_,()>::Ok(crate::api::buffer::ChannelData::from(api_data))
                    })())
                } })
            }fn wire__crate__api__buffer__ChannelData_is_empty_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ChannelData_is_empty", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelData>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::buffer::ChannelData::is_empty(&api_that))
                    })())
                } })
            }fn wire__crate__api__buffer__ChannelData_len_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ChannelData_len", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelData>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::buffer::ChannelData::len(&api_that))
                    })())
                } })
            }fn wire__crate__api__buffer__ChannelData_new_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ChannelData_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_length = <usize>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                         Result::<_,()>::Ok(crate::api::buffer::ChannelData::new(api_length))
                    })())
                } })
            }fn wire__crate__api__context__concrete_base__ConcreteBaseAudioContext_mark_cycle_breaker_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ConcreteBaseAudioContext_mark_cycle_breaker", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConcreteBaseAudioContext>>>::sse_decode(&mut deserializer);
let api_reg = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContextRegistration>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_reg_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_reg, 1, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
1 => api_reg_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_reg)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
let api_reg = api_reg_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::concrete_base::ConcreteBaseAudioContext::mark_cycle_breaker(&api_that, &api_reg))
                    })())
                } })
            }fn wire__crate__api__context__offline__OfflineAudioContext_clear_oncomplete_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OfflineAudioContext_clear_oncomplete", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::offline::OfflineAudioContext::clear_oncomplete(&api_that))
                    })())
                } })
            }fn wire__crate__api__context__offline__OfflineAudioContext_length_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OfflineAudioContext_length", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::offline::OfflineAudioContext::length(&api_that))
                    })())
                } })
            }fn wire__crate__api__context__offline__OfflineAudioContext_new_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OfflineAudioContext_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_number_of_channels = <usize>::sse_decode(&mut deserializer);
let api_length = <usize>::sse_decode(&mut deserializer);
let api_sample_rate = <f32>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                         Result::<_,()>::Ok(crate::api::context::offline::OfflineAudioContext::new(api_number_of_channels, api_length, api_sample_rate))
                    })())
                } })
            }fn wire__crate__api__context__offline__OfflineAudioContext_resume_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OfflineAudioContext_resume", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_async_ref(&api_that).await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::offline::OfflineAudioContext::resume(&api_that).await)
                    })().await)
                } })
            }fn wire__crate__api__context__offline__OfflineAudioContext_set_oncomplete_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OfflineAudioContext_set_oncomplete", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioContext>>>::sse_decode(&mut deserializer);
let api_callback = <F>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::offline::OfflineAudioContext::set_oncomplete(&api_that, api_callback))
                    })())
                } })
            }fn wire__crate__api__context__offline__OfflineAudioContext_start_rendering_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OfflineAudioContext_start_rendering", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_async_ref(&api_that).await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::offline::OfflineAudioContext::start_rendering(&api_that).await)
                    })().await)
                } })
            }fn wire__crate__api__context__offline__OfflineAudioContext_start_rendering_sync_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OfflineAudioContext_start_rendering_sync", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::offline::OfflineAudioContext::start_rendering_sync(&mut api_that))
                    })())
                } })
            }fn wire__crate__api__context__offline__OfflineAudioContext_suspend_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OfflineAudioContext_suspend", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioContext>>>::sse_decode(&mut deserializer);
let api_suspend_time = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_async_ref(&api_that).await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::offline::OfflineAudioContext::suspend(&api_that, api_suspend_time).await)
                    })().await)
                } })
            }fn wire__crate__api__context__offline__OfflineAudioContext_suspend_sync_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OfflineAudioContext_suspend_sync", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioContext>>>::sse_decode(&mut deserializer);
let api_suspend_time = <f64>::sse_decode(&mut deserializer);
let api_callback = <F>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::offline::OfflineAudioContext::suspend_sync(&mut api_that, api_suspend_time, api_callback))
                    })())
                } })
            }fn wire__crate__api__context__online__AudioContext_base_latency_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_base_latency", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::online::AudioContext::base_latency(&api_that))
                    })())
                } })
            }fn wire__crate__api__context__online__AudioContext_clear_onsinkchange_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_clear_onsinkchange", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::online::AudioContext::clear_onsinkchange(&api_that))
                    })())
                } })
            }fn wire__crate__api__context__online__AudioContext_close_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_close", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_async_ref(&api_that).await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::online::AudioContext::close(&api_that).await)
                    })().await)
                } })
            }fn wire__crate__api__context__online__AudioContext_close_sync_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_close_sync", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::online::AudioContext::close_sync(&api_that))
                    })())
                } })
            }fn wire__crate__api__context__online__AudioContext_create_media_element_source_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_create_media_element_source", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);
let api_media_element = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_media_element_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_media_element, 1, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
1 => api_media_element_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_media_element)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
let mut api_media_element = api_media_element_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::online::AudioContext::create_media_element_source(&api_that, &mut api_media_element))
                    })())
                } })
            }fn wire__crate__api__context__online__AudioContext_create_media_stream_destination_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_create_media_stream_destination", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::online::AudioContext::create_media_stream_destination(&api_that))
                    })())
                } })
            }fn wire__crate__api__context__online__AudioContext_create_media_stream_source_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_create_media_stream_source", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);
let api_media = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStream>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_media_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_media, 1, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
1 => api_media_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_media)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
let api_media = api_media_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::online::AudioContext::create_media_stream_source(&api_that, &api_media))
                    })())
                } })
            }fn wire__crate__api__context__online__AudioContext_create_media_stream_track_source_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_create_media_stream_track_source", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);
let api_media = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamTrack>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_media_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_media, 1, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
1 => api_media_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_media)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
let api_media = api_media_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::online::AudioContext::create_media_stream_track_source(&api_that, &api_media))
                    })())
                } })
            }fn wire__crate__api__context__online__AudioContext_new_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_options = <crate::api::context::online::AudioContextOptions>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                         Result::<_,()>::Ok(crate::api::context::online::AudioContext::new(api_options))
                    })())
                } })
            }fn wire__crate__api__context__online__AudioContext_output_latency_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_output_latency", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::online::AudioContext::output_latency(&api_that))
                    })())
                } })
            }fn wire__crate__api__context__online__AudioContext_render_capacity_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_render_capacity", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::online::AudioContext::render_capacity(&api_that))
                    })())
                } })
            }fn wire__crate__api__context__online__AudioContext_resume_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_resume", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_async_ref(&api_that).await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::online::AudioContext::resume(&api_that).await)
                    })().await)
                } })
            }fn wire__crate__api__context__online__AudioContext_resume_sync_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_resume_sync", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::online::AudioContext::resume_sync(&api_that))
                    })())
                } })
            }fn wire__crate__api__context__online__AudioContext_run_diagnostics_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_run_diagnostics", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);
let api_callback = <F>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::online::AudioContext::run_diagnostics(&api_that, api_callback))
                    })())
                } })
            }fn wire__crate__api__context__online__AudioContext_set_onsinkchange_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_set_onsinkchange", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);
let api_callback = <F>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::online::AudioContext::set_onsinkchange(&api_that, api_callback))
                    })())
                } })
            }fn wire__crate__api__context__online__AudioContext_set_sink_id_sync_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_set_sink_id_sync", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);
let api_sink_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 crate::api::context::online::AudioContext::set_sink_id_sync(&api_that, api_sink_id)
                    })())
                } })
            }fn wire__crate__api__context__online__AudioContext_sink_id_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_sink_id", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::online::AudioContext::sink_id(&api_that))
                    })())
                } })
            }fn wire__crate__api__context__online__AudioContext_suspend_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_suspend", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_async_ref(&api_that).await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::online::AudioContext::suspend(&api_that).await)
                    })().await)
                } })
            }fn wire__crate__api__context__online__AudioContext_suspend_sync_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_suspend_sync", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::online::AudioContext::suspend_sync(&api_that))
                    })())
                } })
            }fn wire__crate__api__decoding__MediaDecoder_try_new_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaDecoder_try_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_input = <R>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                         crate::api::decoding::MediaDecoder::try_new(api_input)
                    })())
                } })
            }fn wire__crate__api__decoding__MediaInput_new_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaInput_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_input = <R>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                         Result::<_,()>::Ok(crate::api::decoding::MediaInput::new(api_input))
                    })())
                } })
            }fn wire__crate__api__media_element__MediaElement_current_time_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaElement_current_time", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::online::MediaElement::current_time(&api_that))
                    })())
                } })
            }fn wire__crate__api__media_element__MediaElement_loop__impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaElement_loop_", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::online::MediaElement::loop_(&api_that))
                    })())
                } })
            }fn wire__crate__api__media_element__MediaElement_new_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaElement_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_file = <P>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                         crate::api::context::online::MediaElement::new(api_file)
                    })())
                } })
            }fn wire__crate__api__media_element__MediaElement_pause_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaElement_pause", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::online::MediaElement::pause(&api_that))
                    })())
                } })
            }fn wire__crate__api__media_element__MediaElement_paused_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaElement_paused", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::online::MediaElement::paused(&api_that))
                    })())
                } })
            }fn wire__crate__api__media_element__MediaElement_play_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaElement_play", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::online::MediaElement::play(&api_that))
                    })())
                } })
            }fn wire__crate__api__media_element__MediaElement_playback_rate_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaElement_playback_rate", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::online::MediaElement::playback_rate(&api_that))
                    })())
                } })
            }fn wire__crate__api__media_element__MediaElement_set_current_time_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaElement_set_current_time", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>>>::sse_decode(&mut deserializer);
let api_value = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::online::MediaElement::set_current_time(&api_that, api_value))
                    })())
                } })
            }fn wire__crate__api__media_element__MediaElement_set_loop_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaElement_set_loop", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>>>::sse_decode(&mut deserializer);
let api_value = <bool>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::online::MediaElement::set_loop(&api_that, api_value))
                    })())
                } })
            }fn wire__crate__api__media_element__MediaElement_set_playback_rate_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaElement_set_playback_rate", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>>>::sse_decode(&mut deserializer);
let api_value = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::context::online::MediaElement::set_playback_rate(&api_that, api_value))
                    })())
                } })
            }fn wire__crate__api__message__OneshotNotify_send_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OneshotNotify_send", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <OneshotNotify>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                         Result::<_,()>::Ok(crate::api::message::OneshotNotify::send(api_that))
                    })())
                } })
            }fn wire__crate__api__message_port__MessagePort_clear_onmessage_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MessagePort_clear_onmessage", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessagePort>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::message_port::MessagePort::clear_onmessage(&api_that))
                    })())
                } })
            }fn wire__crate__api__message_port__MessagePort_post_message_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MessagePort_post_message", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessagePort>>>::sse_decode(&mut deserializer);
let api_msg = <M>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::message_port::MessagePort::post_message(&api_that, api_msg))
                    })())
                } })
            }fn wire__crate__api__message_port__MessagePort_set_onmessage_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MessagePort_set_onmessage", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessagePort>>>::sse_decode(&mut deserializer);
let api_callback = <F>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::message_port::MessagePort::set_onmessage(&api_that, api_callback))
                    })())
                } })
            }fn wire__crate__api__param__AudioParam_automation_rate_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioParam_automation_rate", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::param::AudioParam::automation_rate(&api_that))
                    })())
                } })
            }fn wire__crate__api__param__AudioParam_cancel_and_hold_at_time_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioParam_cancel_and_hold_at_time", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(&mut deserializer);
let api_cancel_time = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::param::AudioParam::cancel_and_hold_at_time(&api_that, api_cancel_time))
                    })())
                } })
            }fn wire__crate__api__param__AudioParam_cancel_scheduled_values_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioParam_cancel_scheduled_values", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(&mut deserializer);
let api_cancel_time = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::param::AudioParam::cancel_scheduled_values(&api_that, api_cancel_time))
                    })())
                } })
            }fn wire__crate__api__param__AudioParam_default_value_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioParam_default_value", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::param::AudioParam::default_value(&api_that))
                    })())
                } })
            }fn wire__crate__api__param__AudioParam_exponential_ramp_to_value_at_time_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioParam_exponential_ramp_to_value_at_time", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(&mut deserializer);
let api_value = <f32>::sse_decode(&mut deserializer);
let api_end_time = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::param::AudioParam::exponential_ramp_to_value_at_time(&api_that, api_value, api_end_time))
                    })())
                } })
            }fn wire__crate__api__param__AudioParam_linear_ramp_to_value_at_time_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioParam_linear_ramp_to_value_at_time", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(&mut deserializer);
let api_value = <f32>::sse_decode(&mut deserializer);
let api_end_time = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::param::AudioParam::linear_ramp_to_value_at_time(&api_that, api_value, api_end_time))
                    })())
                } })
            }fn wire__crate__api__param__AudioParam_max_value_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioParam_max_value", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::param::AudioParam::max_value(&api_that))
                    })())
                } })
            }fn wire__crate__api__param__AudioParam_min_value_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioParam_min_value", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::param::AudioParam::min_value(&api_that))
                    })())
                } })
            }fn wire__crate__api__param__AudioParam_set_automation_rate_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioParam_set_automation_rate", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(&mut deserializer);
let api_value = <crate::api::param::AutomationRate>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::param::AudioParam::set_automation_rate(&api_that, api_value))
                    })())
                } })
            }fn wire__crate__api__param__AudioParam_set_target_at_time_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioParam_set_target_at_time", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(&mut deserializer);
let api_value = <f32>::sse_decode(&mut deserializer);
let api_start_time = <f64>::sse_decode(&mut deserializer);
let api_time_constant = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::param::AudioParam::set_target_at_time(&api_that, api_value, api_start_time, api_time_constant))
                    })())
                } })
            }fn wire__crate__api__param__AudioParam_set_value_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioParam_set_value", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(&mut deserializer);
let api_value = <f32>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::param::AudioParam::set_value(&api_that, api_value))
                    })())
                } })
            }fn wire__crate__api__param__AudioParam_set_value_at_time_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioParam_set_value_at_time", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(&mut deserializer);
let api_value = <f32>::sse_decode(&mut deserializer);
let api_start_time = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::param::AudioParam::set_value_at_time(&api_that, api_value, api_start_time))
                    })())
                } })
            }fn wire__crate__api__param__AudioParam_set_value_curve_at_time_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioParam_set_value_curve_at_time", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(&mut deserializer);
let api_values = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>>>::sse_decode(&mut deserializer);
let api_start_time = <f64>::sse_decode(&mut deserializer);
let api_duration = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_values_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_values, 1, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
1 => api_values_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_values)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
let api_values = api_values_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::param::AudioParam::set_value_curve_at_time(&api_that, &api_values, api_start_time, api_duration))
                    })())
                } })
            }fn wire__crate__api__param__AudioParam_value_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioParam_value", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::param::AudioParam::value(&api_that))
                    })())
                } })
            }fn wire__crate__api__periodic_wave__PeriodicWave_new_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "PeriodicWave_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api__context = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>>>::sse_decode(&mut deserializer);
let api_options = <crate::api::periodic_wave::PeriodicWaveOptions>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api__context_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api__context, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api__context_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api__context)),
                _ => unreachable!(),
            }
        }
        let api__context = api__context_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::periodic_wave::PeriodicWave::new(&api__context, api_options))
                    })())
                } })
            }fn wire__crate__api__resampling__Resampler_new_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Resampler_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sample_rate = <f32>::sse_decode(&mut deserializer);
let api_sample_len = <usize>::sse_decode(&mut deserializer);
let api_input = <M>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                         Result::<_,()>::Ok(crate::api::resampling::Resampler::new(api_sample_rate, api_sample_len, api_input))
                    })())
                } })
            }fn wire__crate__api__spatial__AudioListenerNode_into_fields_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioListenerNode_into_fields", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <AudioListenerNode>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                         Result::<_,()>::Ok(crate::api::spatial::AudioListenerNode::into_fields(api_that))
                    })())
                } })
            }fn wire__crate__api__spatial__AudioListenerNode_new_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioListenerNode_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_context = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_context_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_context, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_context_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_context)),
                _ => unreachable!(),
            }
        }
        let api_context = api_context_decoded.unwrap();
 Result::<_,()>::Ok(crate::api::spatial::AudioListenerNode::new(&api_context))
                    })())
                } })
            }fn wire__crate__api__spatial__angle_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "angle", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_source_position = <Vector3 < f32 >>::sse_decode(&mut deserializer);
let api_source_orientation = <Vector3 < f32 >>::sse_decode(&mut deserializer);
let api_listener_position = <Vector3 < f32 >>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                         Result::<_,()>::Ok(crate::api::spatial::angle(api_source_position, api_source_orientation, api_listener_position))
                    })())
                } })
            }fn wire__crate__api__spatial__audio_listener_forward_x_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "audio_listener_forward_x", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::spatial::AudioListener>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                         Result::<_,()>::Ok(crate::api::spatial::AudioListener::forward_x(&api_that))
                    })())
                } })
            }fn wire__crate__api__spatial__audio_listener_forward_y_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "audio_listener_forward_y", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::spatial::AudioListener>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                         Result::<_,()>::Ok(crate::api::spatial::AudioListener::forward_y(&api_that))
                    })())
                } })
            }fn wire__crate__api__spatial__audio_listener_forward_z_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "audio_listener_forward_z", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::spatial::AudioListener>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                         Result::<_,()>::Ok(crate::api::spatial::AudioListener::forward_z(&api_that))
                    })())
                } })
            }fn wire__crate__api__spatial__audio_listener_position_x_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "audio_listener_position_x", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::spatial::AudioListener>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                         Result::<_,()>::Ok(crate::api::spatial::AudioListener::position_x(&api_that))
                    })())
                } })
            }fn wire__crate__api__spatial__audio_listener_position_y_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "audio_listener_position_y", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::spatial::AudioListener>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                         Result::<_,()>::Ok(crate::api::spatial::AudioListener::position_y(&api_that))
                    })())
                } })
            }fn wire__crate__api__spatial__audio_listener_position_z_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "audio_listener_position_z", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::spatial::AudioListener>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                         Result::<_,()>::Ok(crate::api::spatial::AudioListener::position_z(&api_that))
                    })())
                } })
            }fn wire__crate__api__spatial__audio_listener_up_x_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "audio_listener_up_x", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::spatial::AudioListener>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                         Result::<_,()>::Ok(crate::api::spatial::AudioListener::up_x(&api_that))
                    })())
                } })
            }fn wire__crate__api__spatial__audio_listener_up_y_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "audio_listener_up_y", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::spatial::AudioListener>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                         Result::<_,()>::Ok(crate::api::spatial::AudioListener::up_y(&api_that))
                    })())
                } })
            }fn wire__crate__api__spatial__audio_listener_up_z_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "audio_listener_up_z", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::spatial::AudioListener>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                         Result::<_,()>::Ok(crate::api::spatial::AudioListener::up_z(&api_that))
                    })())
                } })
            }fn wire__crate__api__spatial__azimuth_and_elevation_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "azimuth_and_elevation", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_source_position = <Vector3 < f32 >>::sse_decode(&mut deserializer);
let api_listener_position = <Vector3 < f32 >>::sse_decode(&mut deserializer);
let api_listener_forward = <Vector3 < f32 >>::sse_decode(&mut deserializer);
let api_listener_up = <Vector3 < f32 >>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                         Result::<_,()>::Ok(crate::api::spatial::azimuth_and_elevation(api_source_position, api_listener_position, api_listener_forward, api_listener_up))
                    })())
                } })
            }fn wire__crate__api__spatial__distance_impl(port_: flutter_rust_bridge::for_generated::MessagePort,ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,rust_vec_len_: i32,data_len_: i32)  {
                FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "distance", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_source_position = <Vector3 < f32 >>::sse_decode(&mut deserializer);
let api_listener_position = <Vector3 < f32 >>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                         Result::<_,()>::Ok(crate::api::spatial::distance(api_source_position, api_listener_position))
                    })())
                } })
            }

// Section: related_funcs

flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserRingBuffer>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AtomicF32>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AtomicF64>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBuffer>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferOptions>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContextRegistration>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerNode>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacity>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box < dyn Error >>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box < dyn std :: error :: Error + Send + Sync >>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelData>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConcreteBaseAudioContext>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<F>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<M>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaDecoder>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaInput>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStream>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamTrack>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessagePort>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioContext>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OneshotNotify>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Ordering>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<P>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeriodicWave>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<R>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Resampler>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Self>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Vector3 < f32 >>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<node :: MediaElementAudioSourceNode>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<node :: MediaStreamAudioDestinationNode>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<node :: MediaStreamAudioSourceNode>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<node :: MediaStreamTrackAudioSourceNode>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[u8]>);


// Section: dart2rust


                impl SseDecode for RustAutoOpaqueMoi<AudioParam> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_explicit_decode(inner);}
                }
                
                impl SseDecode for Analyser {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for AnalyserRingBuffer {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserRingBuffer>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for AtomicF32 {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AtomicF32>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for AtomicF64 {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AtomicF64>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for AudioBuffer {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBuffer>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for AudioBufferOptions {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferOptions>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for AudioContext {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for AudioListenerNode {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerNode>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for AudioParam {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for AudioRenderCapacity {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacity>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for Box < dyn Error > {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box < dyn Error >>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for Box < dyn std :: error :: Error + Send + Sync > {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box < dyn std :: error :: Error + Send + Sync >>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for ChannelData {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelData>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for ConcreteBaseAudioContext {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConcreteBaseAudioContext>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for F {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<F>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for M {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<M>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for MediaDecoder {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaDecoder>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for MediaElement {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for MediaInput {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaInput>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for MessagePort {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessagePort>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for OfflineAudioContext {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioContext>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for OneshotNotify {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OneshotNotify>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for Ordering {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Ordering>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for P {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<P>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for PeriodicWave {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeriodicWave>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for R {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<R>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for Resampler {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Resampler>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for Vector3 < f32 > {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Vector3 < f32 >>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for node :: MediaElementAudioSourceNode {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<node :: MediaElementAudioSourceNode>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for node :: MediaStreamAudioDestinationNode {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<node :: MediaStreamAudioDestinationNode>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for node :: MediaStreamAudioSourceNode {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<node :: MediaStreamAudioSourceNode>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for node :: MediaStreamTrackAudioSourceNode {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<node :: MediaStreamTrackAudioSourceNode>>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserRingBuffer>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AtomicF32>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AtomicF64>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBuffer>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferOptions>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContextRegistration>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerNode>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacity>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box < dyn Error >>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box < dyn std :: error :: Error + Send + Sync >>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelData>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConcreteBaseAudioContext>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<F>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<M>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaDecoder>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaInput>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStream>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamTrack>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessagePort>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioContext>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OneshotNotify>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Ordering>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<P>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeriodicWave>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<R>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Resampler>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Self>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Vector3 < f32 >>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<node :: MediaElementAudioSourceNode>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<node :: MediaStreamAudioDestinationNode>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<node :: MediaStreamAudioSourceNode>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<node :: MediaStreamTrackAudioSourceNode>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[u8]>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);}
                }
                
                impl SseDecode for String {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();}
                }
                
                impl SseDecode for crate::api::context::online::AudioContextLatencyCategory {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut tag_ = <i32>::sse_decode(deserializer);
            match tag_ {0 => { return crate::api::context::online::AudioContextLatencyCategory::Balanced; }
1 => { return crate::api::context::online::AudioContextLatencyCategory::Interactive; }
2 => { return crate::api::context::online::AudioContextLatencyCategory::Playback; }
3 => { let mut var_field0 = <f64>::sse_decode(deserializer);
return crate::api::context::online::AudioContextLatencyCategory::Custom(var_field0); }
 _ => { unimplemented!(""); }}}
                }
                
                impl SseDecode for crate::api::context::online::AudioContextOptions {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut var_latencyHint = <crate::api::context::online::AudioContextLatencyCategory>::sse_decode(deserializer);
let mut var_sampleRate = <Option<f32>>::sse_decode(deserializer);
let mut var_sinkId = <String>::sse_decode(deserializer);
let mut var_renderSizeHint = <crate::api::context::online::AudioContextRenderSizeCategory>::sse_decode(deserializer);
return crate::api::context::online::AudioContextOptions{latency_hint: var_latencyHint, sample_rate: var_sampleRate, sink_id: var_sinkId, render_size_hint: var_renderSizeHint};}
                }
                
                impl SseDecode for crate::api::context::online::AudioContextRenderSizeCategory {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::context::online::AudioContextRenderSizeCategory::Default,
            _ => unreachable!("Invalid variant for AudioContextRenderSizeCategory: {}", inner),
        };}
                }
                
                impl SseDecode for crate::api::spatial::AudioListener {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut var_positionX = <RustAutoOpaqueMoi<AudioParam>>::sse_decode(deserializer);
let mut var_positionY = <RustAutoOpaqueMoi<AudioParam>>::sse_decode(deserializer);
let mut var_positionZ = <RustAutoOpaqueMoi<AudioParam>>::sse_decode(deserializer);
let mut var_forwardX = <RustAutoOpaqueMoi<AudioParam>>::sse_decode(deserializer);
let mut var_forwardY = <RustAutoOpaqueMoi<AudioParam>>::sse_decode(deserializer);
let mut var_forwardZ = <RustAutoOpaqueMoi<AudioParam>>::sse_decode(deserializer);
let mut var_upX = <RustAutoOpaqueMoi<AudioParam>>::sse_decode(deserializer);
let mut var_upY = <RustAutoOpaqueMoi<AudioParam>>::sse_decode(deserializer);
let mut var_upZ = <RustAutoOpaqueMoi<AudioParam>>::sse_decode(deserializer);
return crate::api::spatial::AudioListener{position_x: var_positionX, position_y: var_positionY, position_z: var_positionZ, forward_x: var_forwardX, forward_y: var_forwardY, forward_z: var_forwardZ, up_x: var_upX, up_y: var_upY, up_z: var_upZ};}
                }
                
                impl SseDecode for crate::api::param::AutomationRate {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::param::AutomationRate::A,
1 => crate::api::param::AutomationRate::K,
            _ => unreachable!("Invalid variant for AutomationRate: {}", inner),
        };}
                }
                
                impl SseDecode for bool {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {deserializer.cursor.read_u8().unwrap() != 0}
                }
                
                impl SseDecode for f32 {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {deserializer.cursor.read_f32::<NativeEndian>().unwrap()}
                }
                
                impl SseDecode for f64 {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {deserializer.cursor.read_f64::<NativeEndian>().unwrap()}
                }
                
                impl SseDecode for i32 {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {deserializer.cursor.read_i32::<NativeEndian>().unwrap()}
                }
                
                impl SseDecode for Vec<Vec<f32>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ { ans_.push(<Vec<f32>>::sse_decode(deserializer)); }
        return ans_;}
                }
                
                impl SseDecode for Vec<f32> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ { ans_.push(<f32>::sse_decode(deserializer)); }
        return ans_;}
                }
                
                impl SseDecode for Vec<u8> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ { ans_.push(<u8>::sse_decode(deserializer)); }
        return ans_;}
                }
                
                impl SseDecode for Option<f32> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {if (<bool>::sse_decode(deserializer)) {
                return Some(<f32>::sse_decode(deserializer));
            } else {
                return None;
            }}
                }
                
                impl SseDecode for Option<Vec<f32>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {if (<bool>::sse_decode(deserializer)) {
                return Some(<Vec<f32>>::sse_decode(deserializer));
            } else {
                return None;
            }}
                }
                
                impl SseDecode for crate::api::periodic_wave::PeriodicWaveOptions {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut var_real = <Option<Vec<f32>>>::sse_decode(deserializer);
let mut var_imag = <Option<Vec<f32>>>::sse_decode(deserializer);
let mut var_disableNormalization = <bool>::sse_decode(deserializer);
return crate::api::periodic_wave::PeriodicWaveOptions{real: var_real, imag: var_imag, disable_normalization: var_disableNormalization};}
                }
                
                impl SseDecode for (f32,f32,) {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut var_field0 = <f32>::sse_decode(deserializer);
let mut var_field1 = <f32>::sse_decode(deserializer);
return (var_field0, var_field1);}
                }
                
                impl SseDecode for u8 {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {deserializer.cursor.read_u8().unwrap()}
                }
                
                impl SseDecode for () {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
                }
                
                impl SseDecode for usize {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _}
                }
                
                fn pde_ffi_dispatcher_primary_impl(
                    func_id: i32,port: flutter_rust_bridge::for_generated::MessagePort,
                    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
                    rust_vec_len: i32,
                    data_len: i32,
                )  {
                    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
                    match func_id {
                        1 => wire__crate__api__analysis__AnalyserRingBuffer_new_impl(port, ptr, rust_vec_len, data_len),
2 => wire__crate__api__analysis__AnalyserRingBuffer_read_impl(port, ptr, rust_vec_len, data_len),
3 => wire__crate__api__analysis__AnalyserRingBuffer_write_impl(port, ptr, rust_vec_len, data_len),
4 => wire__crate__api__analysis__Analyser_fft_size_impl(port, ptr, rust_vec_len, data_len),
5 => wire__crate__api__analysis__Analyser_frequency_bin_count_impl(port, ptr, rust_vec_len, data_len),
6 => wire__crate__api__analysis__Analyser_get_byte_frequency_data_impl(port, ptr, rust_vec_len, data_len),
7 => wire__crate__api__analysis__Analyser_get_byte_time_domain_data_impl(port, ptr, rust_vec_len, data_len),
8 => wire__crate__api__analysis__Analyser_get_float_frequency_data_impl(port, ptr, rust_vec_len, data_len),
9 => wire__crate__api__analysis__Analyser_get_float_time_domain_data_impl(port, ptr, rust_vec_len, data_len),
10 => wire__crate__api__analysis__Analyser_get_ring_buffer_clone_impl(port, ptr, rust_vec_len, data_len),
11 => wire__crate__api__analysis__Analyser_max_decibels_impl(port, ptr, rust_vec_len, data_len),
12 => wire__crate__api__analysis__Analyser_min_decibels_impl(port, ptr, rust_vec_len, data_len),
13 => wire__crate__api__analysis__Analyser_new_impl(port, ptr, rust_vec_len, data_len),
14 => wire__crate__api__analysis__Analyser_set_decibels_impl(port, ptr, rust_vec_len, data_len),
15 => wire__crate__api__analysis__Analyser_set_fft_size_impl(port, ptr, rust_vec_len, data_len),
16 => wire__crate__api__analysis__Analyser_set_smoothing_time_constant_impl(port, ptr, rust_vec_len, data_len),
17 => wire__crate__api__analysis__Analyser_smoothing_time_constant_impl(port, ptr, rust_vec_len, data_len),
18 => wire__crate__api__api__AtomicF32_load_impl(port, ptr, rust_vec_len, data_len),
19 => wire__crate__api__api__AtomicF32_new_impl(port, ptr, rust_vec_len, data_len),
20 => wire__crate__api__api__AtomicF32_store_impl(port, ptr, rust_vec_len, data_len),
21 => wire__crate__api__api__AtomicF64_load_impl(port, ptr, rust_vec_len, data_len),
22 => wire__crate__api__api__AtomicF64_new_impl(port, ptr, rust_vec_len, data_len),
23 => wire__crate__api__api__AtomicF64_store_impl(port, ptr, rust_vec_len, data_len),
30 => wire__crate__api__buffer__AudioBuffer_copy_from_channel_impl(port, ptr, rust_vec_len, data_len),
31 => wire__crate__api__buffer__AudioBuffer_copy_from_channel_with_offset_impl(port, ptr, rust_vec_len, data_len),
32 => wire__crate__api__buffer__AudioBuffer_copy_to_channel_impl(port, ptr, rust_vec_len, data_len),
33 => wire__crate__api__buffer__AudioBuffer_copy_to_channel_with_offset_impl(port, ptr, rust_vec_len, data_len),
34 => wire__crate__api__buffer__AudioBuffer_duration_impl(port, ptr, rust_vec_len, data_len),
35 => wire__crate__api__buffer__AudioBuffer_from_impl(port, ptr, rust_vec_len, data_len),
36 => wire__crate__api__buffer__AudioBuffer_get_channel_data_impl(port, ptr, rust_vec_len, data_len),
37 => wire__crate__api__buffer__AudioBuffer_get_channel_data_mut_impl(port, ptr, rust_vec_len, data_len),
38 => wire__crate__api__buffer__AudioBuffer_length_impl(port, ptr, rust_vec_len, data_len),
39 => wire__crate__api__buffer__AudioBuffer_new_impl(port, ptr, rust_vec_len, data_len),
40 => wire__crate__api__buffer__AudioBuffer_number_of_channels_impl(port, ptr, rust_vec_len, data_len),
41 => wire__crate__api__buffer__AudioBuffer_sample_rate_impl(port, ptr, rust_vec_len, data_len),
42 => wire__crate__api__buffer__ChannelData_as_mut_slice_impl(port, ptr, rust_vec_len, data_len),
43 => wire__crate__api__buffer__ChannelData_as_slice_impl(port, ptr, rust_vec_len, data_len),
44 => wire__crate__api__buffer__ChannelData_from_impl(port, ptr, rust_vec_len, data_len),
45 => wire__crate__api__buffer__ChannelData_is_empty_impl(port, ptr, rust_vec_len, data_len),
46 => wire__crate__api__buffer__ChannelData_len_impl(port, ptr, rust_vec_len, data_len),
47 => wire__crate__api__buffer__ChannelData_new_impl(port, ptr, rust_vec_len, data_len),
48 => wire__crate__api__context__concrete_base__ConcreteBaseAudioContext_mark_cycle_breaker_impl(port, ptr, rust_vec_len, data_len),
49 => wire__crate__api__context__offline__OfflineAudioContext_clear_oncomplete_impl(port, ptr, rust_vec_len, data_len),
50 => wire__crate__api__context__offline__OfflineAudioContext_length_impl(port, ptr, rust_vec_len, data_len),
51 => wire__crate__api__context__offline__OfflineAudioContext_new_impl(port, ptr, rust_vec_len, data_len),
52 => wire__crate__api__context__offline__OfflineAudioContext_resume_impl(port, ptr, rust_vec_len, data_len),
53 => wire__crate__api__context__offline__OfflineAudioContext_set_oncomplete_impl(port, ptr, rust_vec_len, data_len),
54 => wire__crate__api__context__offline__OfflineAudioContext_start_rendering_impl(port, ptr, rust_vec_len, data_len),
55 => wire__crate__api__context__offline__OfflineAudioContext_start_rendering_sync_impl(port, ptr, rust_vec_len, data_len),
56 => wire__crate__api__context__offline__OfflineAudioContext_suspend_impl(port, ptr, rust_vec_len, data_len),
57 => wire__crate__api__context__offline__OfflineAudioContext_suspend_sync_impl(port, ptr, rust_vec_len, data_len),
58 => wire__crate__api__context__online__AudioContext_base_latency_impl(port, ptr, rust_vec_len, data_len),
59 => wire__crate__api__context__online__AudioContext_clear_onsinkchange_impl(port, ptr, rust_vec_len, data_len),
60 => wire__crate__api__context__online__AudioContext_close_impl(port, ptr, rust_vec_len, data_len),
61 => wire__crate__api__context__online__AudioContext_close_sync_impl(port, ptr, rust_vec_len, data_len),
62 => wire__crate__api__context__online__AudioContext_create_media_element_source_impl(port, ptr, rust_vec_len, data_len),
63 => wire__crate__api__context__online__AudioContext_create_media_stream_destination_impl(port, ptr, rust_vec_len, data_len),
64 => wire__crate__api__context__online__AudioContext_create_media_stream_source_impl(port, ptr, rust_vec_len, data_len),
65 => wire__crate__api__context__online__AudioContext_create_media_stream_track_source_impl(port, ptr, rust_vec_len, data_len),
66 => wire__crate__api__context__online__AudioContext_new_impl(port, ptr, rust_vec_len, data_len),
67 => wire__crate__api__context__online__AudioContext_output_latency_impl(port, ptr, rust_vec_len, data_len),
68 => wire__crate__api__context__online__AudioContext_render_capacity_impl(port, ptr, rust_vec_len, data_len),
69 => wire__crate__api__context__online__AudioContext_resume_impl(port, ptr, rust_vec_len, data_len),
70 => wire__crate__api__context__online__AudioContext_resume_sync_impl(port, ptr, rust_vec_len, data_len),
71 => wire__crate__api__context__online__AudioContext_run_diagnostics_impl(port, ptr, rust_vec_len, data_len),
72 => wire__crate__api__context__online__AudioContext_set_onsinkchange_impl(port, ptr, rust_vec_len, data_len),
73 => wire__crate__api__context__online__AudioContext_set_sink_id_sync_impl(port, ptr, rust_vec_len, data_len),
74 => wire__crate__api__context__online__AudioContext_sink_id_impl(port, ptr, rust_vec_len, data_len),
75 => wire__crate__api__context__online__AudioContext_suspend_impl(port, ptr, rust_vec_len, data_len),
76 => wire__crate__api__context__online__AudioContext_suspend_sync_impl(port, ptr, rust_vec_len, data_len),
77 => wire__crate__api__decoding__MediaDecoder_try_new_impl(port, ptr, rust_vec_len, data_len),
78 => wire__crate__api__decoding__MediaInput_new_impl(port, ptr, rust_vec_len, data_len),
79 => wire__crate__api__media_element__MediaElement_current_time_impl(port, ptr, rust_vec_len, data_len),
80 => wire__crate__api__media_element__MediaElement_loop__impl(port, ptr, rust_vec_len, data_len),
81 => wire__crate__api__media_element__MediaElement_new_impl(port, ptr, rust_vec_len, data_len),
82 => wire__crate__api__media_element__MediaElement_pause_impl(port, ptr, rust_vec_len, data_len),
83 => wire__crate__api__media_element__MediaElement_paused_impl(port, ptr, rust_vec_len, data_len),
84 => wire__crate__api__media_element__MediaElement_play_impl(port, ptr, rust_vec_len, data_len),
85 => wire__crate__api__media_element__MediaElement_playback_rate_impl(port, ptr, rust_vec_len, data_len),
86 => wire__crate__api__media_element__MediaElement_set_current_time_impl(port, ptr, rust_vec_len, data_len),
87 => wire__crate__api__media_element__MediaElement_set_loop_impl(port, ptr, rust_vec_len, data_len),
88 => wire__crate__api__media_element__MediaElement_set_playback_rate_impl(port, ptr, rust_vec_len, data_len),
89 => wire__crate__api__message__OneshotNotify_send_impl(port, ptr, rust_vec_len, data_len),
90 => wire__crate__api__message_port__MessagePort_clear_onmessage_impl(port, ptr, rust_vec_len, data_len),
91 => wire__crate__api__message_port__MessagePort_post_message_impl(port, ptr, rust_vec_len, data_len),
92 => wire__crate__api__message_port__MessagePort_set_onmessage_impl(port, ptr, rust_vec_len, data_len),
93 => wire__crate__api__param__AudioParam_automation_rate_impl(port, ptr, rust_vec_len, data_len),
94 => wire__crate__api__param__AudioParam_cancel_and_hold_at_time_impl(port, ptr, rust_vec_len, data_len),
95 => wire__crate__api__param__AudioParam_cancel_scheduled_values_impl(port, ptr, rust_vec_len, data_len),
96 => wire__crate__api__param__AudioParam_default_value_impl(port, ptr, rust_vec_len, data_len),
97 => wire__crate__api__param__AudioParam_exponential_ramp_to_value_at_time_impl(port, ptr, rust_vec_len, data_len),
98 => wire__crate__api__param__AudioParam_linear_ramp_to_value_at_time_impl(port, ptr, rust_vec_len, data_len),
99 => wire__crate__api__param__AudioParam_max_value_impl(port, ptr, rust_vec_len, data_len),
100 => wire__crate__api__param__AudioParam_min_value_impl(port, ptr, rust_vec_len, data_len),
101 => wire__crate__api__param__AudioParam_set_automation_rate_impl(port, ptr, rust_vec_len, data_len),
102 => wire__crate__api__param__AudioParam_set_target_at_time_impl(port, ptr, rust_vec_len, data_len),
103 => wire__crate__api__param__AudioParam_set_value_impl(port, ptr, rust_vec_len, data_len),
104 => wire__crate__api__param__AudioParam_set_value_at_time_impl(port, ptr, rust_vec_len, data_len),
105 => wire__crate__api__param__AudioParam_set_value_curve_at_time_impl(port, ptr, rust_vec_len, data_len),
106 => wire__crate__api__param__AudioParam_value_impl(port, ptr, rust_vec_len, data_len),
107 => wire__crate__api__periodic_wave__PeriodicWave_new_impl(port, ptr, rust_vec_len, data_len),
108 => wire__crate__api__resampling__Resampler_new_impl(port, ptr, rust_vec_len, data_len),
109 => wire__crate__api__spatial__AudioListenerNode_into_fields_impl(port, ptr, rust_vec_len, data_len),
110 => wire__crate__api__spatial__AudioListenerNode_new_impl(port, ptr, rust_vec_len, data_len),
111 => wire__crate__api__spatial__angle_impl(port, ptr, rust_vec_len, data_len),
112 => wire__crate__api__spatial__audio_listener_forward_x_impl(port, ptr, rust_vec_len, data_len),
113 => wire__crate__api__spatial__audio_listener_forward_y_impl(port, ptr, rust_vec_len, data_len),
114 => wire__crate__api__spatial__audio_listener_forward_z_impl(port, ptr, rust_vec_len, data_len),
115 => wire__crate__api__spatial__audio_listener_position_x_impl(port, ptr, rust_vec_len, data_len),
116 => wire__crate__api__spatial__audio_listener_position_y_impl(port, ptr, rust_vec_len, data_len),
117 => wire__crate__api__spatial__audio_listener_position_z_impl(port, ptr, rust_vec_len, data_len),
118 => wire__crate__api__spatial__audio_listener_up_x_impl(port, ptr, rust_vec_len, data_len),
119 => wire__crate__api__spatial__audio_listener_up_y_impl(port, ptr, rust_vec_len, data_len),
120 => wire__crate__api__spatial__audio_listener_up_z_impl(port, ptr, rust_vec_len, data_len),
121 => wire__crate__api__spatial__azimuth_and_elevation_impl(port, ptr, rust_vec_len, data_len),
122 => wire__crate__api__spatial__distance_impl(port, ptr, rust_vec_len, data_len),
                        _ => unreachable!(),
                    }
                }
                
                fn pde_ffi_dispatcher_sync_impl(
                    func_id: i32,
                    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
                    rust_vec_len: i32,
                    data_len: i32,
                ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
                    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
                    match func_id {
                        24 => wire__crate__api__buffer__AudioBufferOptions_get_length_impl(ptr, rust_vec_len, data_len),
25 => wire__crate__api__buffer__AudioBufferOptions_get_number_of_channels_impl(ptr, rust_vec_len, data_len),
26 => wire__crate__api__buffer__AudioBufferOptions_get_sample_rate_impl(ptr, rust_vec_len, data_len),
27 => wire__crate__api__buffer__AudioBufferOptions_set_length_impl(ptr, rust_vec_len, data_len),
28 => wire__crate__api__buffer__AudioBufferOptions_set_number_of_channels_impl(ptr, rust_vec_len, data_len),
29 => wire__crate__api__buffer__AudioBufferOptions_set_sample_rate_impl(ptr, rust_vec_len, data_len),
                        _ => unreachable!(),
                    }
                }
                

// Section: rust2dart


                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<Analyser> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Analyser> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Analyser>> for Analyser {
            fn into_into_dart(self) -> FrbWrapper<Analyser> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<AnalyserRingBuffer> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<AnalyserRingBuffer> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AnalyserRingBuffer>> for AnalyserRingBuffer {
            fn into_into_dart(self) -> FrbWrapper<AnalyserRingBuffer> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<AtomicF32> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<AtomicF32> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AtomicF32>> for AtomicF32 {
            fn into_into_dart(self) -> FrbWrapper<AtomicF32> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<AtomicF64> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<AtomicF64> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AtomicF64>> for AtomicF64 {
            fn into_into_dart(self) -> FrbWrapper<AtomicF64> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<AudioBuffer> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<AudioBuffer> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AudioBuffer>> for AudioBuffer {
            fn into_into_dart(self) -> FrbWrapper<AudioBuffer> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<AudioBufferOptions> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<AudioBufferOptions> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AudioBufferOptions>> for AudioBufferOptions {
            fn into_into_dart(self) -> FrbWrapper<AudioBufferOptions> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<AudioContext> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<AudioContext> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AudioContext>> for AudioContext {
            fn into_into_dart(self) -> FrbWrapper<AudioContext> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<AudioListenerNode> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<AudioListenerNode> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AudioListenerNode>> for AudioListenerNode {
            fn into_into_dart(self) -> FrbWrapper<AudioListenerNode> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<AudioParam> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<AudioParam> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AudioParam>> for AudioParam {
            fn into_into_dart(self) -> FrbWrapper<AudioParam> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<AudioRenderCapacity> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<AudioRenderCapacity> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AudioRenderCapacity>> for AudioRenderCapacity {
            fn into_into_dart(self) -> FrbWrapper<AudioRenderCapacity> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<Box < dyn Error >> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Box < dyn Error >> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Box < dyn Error >>> for Box < dyn Error > {
            fn into_into_dart(self) -> FrbWrapper<Box < dyn Error >> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<Box < dyn std :: error :: Error + Send + Sync >> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Box < dyn std :: error :: Error + Send + Sync >> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Box < dyn std :: error :: Error + Send + Sync >>> for Box < dyn std :: error :: Error + Send + Sync > {
            fn into_into_dart(self) -> FrbWrapper<Box < dyn std :: error :: Error + Send + Sync >> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<ChannelData> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ChannelData> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ChannelData>> for ChannelData {
            fn into_into_dart(self) -> FrbWrapper<ChannelData> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<ConcreteBaseAudioContext> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ConcreteBaseAudioContext> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ConcreteBaseAudioContext>> for ConcreteBaseAudioContext {
            fn into_into_dart(self) -> FrbWrapper<ConcreteBaseAudioContext> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<F> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<F> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<F>> for F {
            fn into_into_dart(self) -> FrbWrapper<F> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<M> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<M> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<M>> for M {
            fn into_into_dart(self) -> FrbWrapper<M> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<MediaDecoder> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<MediaDecoder> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<MediaDecoder>> for MediaDecoder {
            fn into_into_dart(self) -> FrbWrapper<MediaDecoder> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<MediaElement> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<MediaElement> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<MediaElement>> for MediaElement {
            fn into_into_dart(self) -> FrbWrapper<MediaElement> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<MediaInput> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<MediaInput> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<MediaInput>> for MediaInput {
            fn into_into_dart(self) -> FrbWrapper<MediaInput> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<MessagePort> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<MessagePort> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<MessagePort>> for MessagePort {
            fn into_into_dart(self) -> FrbWrapper<MessagePort> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<OfflineAudioContext> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<OfflineAudioContext> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<OfflineAudioContext>> for OfflineAudioContext {
            fn into_into_dart(self) -> FrbWrapper<OfflineAudioContext> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<OneshotNotify> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<OneshotNotify> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<OneshotNotify>> for OneshotNotify {
            fn into_into_dart(self) -> FrbWrapper<OneshotNotify> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<Ordering> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Ordering> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Ordering>> for Ordering {
            fn into_into_dart(self) -> FrbWrapper<Ordering> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<P> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<P> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<P>> for P {
            fn into_into_dart(self) -> FrbWrapper<P> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<PeriodicWave> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<PeriodicWave> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<PeriodicWave>> for PeriodicWave {
            fn into_into_dart(self) -> FrbWrapper<PeriodicWave> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<R> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<R> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<R>> for R {
            fn into_into_dart(self) -> FrbWrapper<R> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<Resampler> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Resampler> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Resampler>> for Resampler {
            fn into_into_dart(self) -> FrbWrapper<Resampler> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<Vector3 < f32 >> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Vector3 < f32 >> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Vector3 < f32 >>> for Vector3 < f32 > {
            fn into_into_dart(self) -> FrbWrapper<Vector3 < f32 >> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<node :: MediaElementAudioSourceNode> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<node :: MediaElementAudioSourceNode> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<node :: MediaElementAudioSourceNode>> for node :: MediaElementAudioSourceNode {
            fn into_into_dart(self) -> FrbWrapper<node :: MediaElementAudioSourceNode> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<node :: MediaStreamAudioDestinationNode> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<node :: MediaStreamAudioDestinationNode> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<node :: MediaStreamAudioDestinationNode>> for node :: MediaStreamAudioDestinationNode {
            fn into_into_dart(self) -> FrbWrapper<node :: MediaStreamAudioDestinationNode> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<node :: MediaStreamAudioSourceNode> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<node :: MediaStreamAudioSourceNode> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<node :: MediaStreamAudioSourceNode>> for node :: MediaStreamAudioSourceNode {
            fn into_into_dart(self) -> FrbWrapper<node :: MediaStreamAudioSourceNode> {
                self.into()
            }
        }

                
                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for FrbWrapper<node :: MediaStreamTrackAudioSourceNode> {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0).into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<node :: MediaStreamTrackAudioSourceNode> {}

                impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<node :: MediaStreamTrackAudioSourceNode>> for node :: MediaStreamTrackAudioSourceNode {
            fn into_into_dart(self) -> FrbWrapper<node :: MediaStreamTrackAudioSourceNode> {
                self.into()
            }
        }

                // Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for crate::api::context::online::AudioContextLatencyCategory {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    match self {crate::api::context::online::AudioContextLatencyCategory::Balanced => { [0.into_dart()].into_dart() }
crate::api::context::online::AudioContextLatencyCategory::Interactive => { [1.into_dart()].into_dart() }
crate::api::context::online::AudioContextLatencyCategory::Playback => { [2.into_dart()].into_dart() }
crate::api::context::online::AudioContextLatencyCategory::Custom(field0) => { [3.into_dart(),
field0.into_into_dart().into_dart()].into_dart() }
 }
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::context::online::AudioContextLatencyCategory {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::context::online::AudioContextLatencyCategory> for crate::api::context::online::AudioContextLatencyCategory {
            fn into_into_dart(self) -> crate::api::context::online::AudioContextLatencyCategory {
                self
            }
        }
// Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for crate::api::context::online::AudioContextOptions {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    [
                    self.latency_hint.into_into_dart().into_dart(),
self.sample_rate.into_into_dart().into_dart(),
self.sink_id.into_into_dart().into_dart(),
self.render_size_hint.into_into_dart().into_dart()
                ].into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::context::online::AudioContextOptions {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::context::online::AudioContextOptions> for crate::api::context::online::AudioContextOptions {
            fn into_into_dart(self) -> crate::api::context::online::AudioContextOptions {
                self
            }
        }
// Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for crate::api::context::online::AudioContextRenderSizeCategory {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    match self {
                    Self::Default => 0.into_dart(),
                }
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::context::online::AudioContextRenderSizeCategory {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::context::online::AudioContextRenderSizeCategory> for crate::api::context::online::AudioContextRenderSizeCategory {
            fn into_into_dart(self) -> crate::api::context::online::AudioContextRenderSizeCategory {
                self
            }
        }
// Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for crate::api::spatial::AudioListener {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    [
                    self.position_x.into_into_dart().into_dart(),
self.position_y.into_into_dart().into_dart(),
self.position_z.into_into_dart().into_dart(),
self.forward_x.into_into_dart().into_dart(),
self.forward_y.into_into_dart().into_dart(),
self.forward_z.into_into_dart().into_dart(),
self.up_x.into_into_dart().into_dart(),
self.up_y.into_into_dart().into_dart(),
self.up_z.into_into_dart().into_dart()
                ].into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::spatial::AudioListener {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::spatial::AudioListener> for crate::api::spatial::AudioListener {
            fn into_into_dart(self) -> crate::api::spatial::AudioListener {
                self
            }
        }
// Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for crate::api::param::AutomationRate {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    match self {
                    Self::A => 0.into_dart(),
Self::K => 1.into_dart(),
                }
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::param::AutomationRate {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::param::AutomationRate> for crate::api::param::AutomationRate {
            fn into_into_dart(self) -> crate::api::param::AutomationRate {
                self
            }
        }
// Codec=Dco (DartCObject based), see doc to use other codecs
            impl flutter_rust_bridge::IntoDart for crate::api::periodic_wave::PeriodicWaveOptions {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    [
                    self.real.into_into_dart().into_dart(),
self.imag.into_into_dart().into_dart(),
self.disable_normalization.into_into_dart().into_dart()
                ].into_dart()
                }
            }
            impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::periodic_wave::PeriodicWaveOptions {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::periodic_wave::PeriodicWaveOptions> for crate::api::periodic_wave::PeriodicWaveOptions {
            fn into_into_dart(self) -> crate::api::periodic_wave::PeriodicWaveOptions {
                self
            }
        }

                impl SseEncode for RustAutoOpaqueMoi<AudioParam> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_explicit_encode(self), serializer);}
                }
                
                impl SseEncode for Analyser {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for AnalyserRingBuffer {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserRingBuffer>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for AtomicF32 {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AtomicF32>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for AtomicF64 {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AtomicF64>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for AudioBuffer {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBuffer>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for AudioBufferOptions {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferOptions>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for AudioContext {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for AudioListenerNode {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerNode>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for AudioParam {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for AudioRenderCapacity {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacity>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for Box < dyn Error > {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box < dyn Error >>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for Box < dyn std :: error :: Error + Send + Sync > {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box < dyn std :: error :: Error + Send + Sync >>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for ChannelData {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelData>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for ConcreteBaseAudioContext {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConcreteBaseAudioContext>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for F {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<F>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for M {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<M>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for MediaDecoder {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaDecoder>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for MediaElement {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for MediaInput {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaInput>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for MessagePort {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessagePort>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for OfflineAudioContext {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioContext>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for OneshotNotify {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OneshotNotify>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for Ordering {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Ordering>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for P {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<P>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for PeriodicWave {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeriodicWave>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for R {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<R>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for Resampler {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Resampler>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for Vector3 < f32 > {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Vector3 < f32 >>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for node :: MediaElementAudioSourceNode {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<node :: MediaElementAudioSourceNode>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for node :: MediaStreamAudioDestinationNode {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<node :: MediaStreamAudioDestinationNode>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for node :: MediaStreamAudioSourceNode {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<node :: MediaStreamAudioSourceNode>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for node :: MediaStreamTrackAudioSourceNode {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<node :: MediaStreamTrackAudioSourceNode>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserRingBuffer>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AtomicF32>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AtomicF64>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBuffer>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferOptions>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContextRegistration>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerNode>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacity>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box < dyn Error >>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box < dyn std :: error :: Error + Send + Sync >>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelData>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConcreteBaseAudioContext>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<F>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<M>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaDecoder>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaInput>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStream>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamTrack>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessagePort>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioContext>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OneshotNotify>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Ordering>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<P>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeriodicWave>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<R>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Resampler>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Self>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Vector3 < f32 >>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<node :: MediaElementAudioSourceNode>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<node :: MediaStreamAudioDestinationNode>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<node :: MediaStreamAudioSourceNode>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<node :: MediaStreamTrackAudioSourceNode>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[u8]>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {let (ptr, size) = self.sse_encode_raw();
                <usize>::sse_encode(ptr, serializer);
                <i32>::sse_encode(size, serializer);}
                }
                
                impl SseEncode for String {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<Vec<u8>>::sse_encode(self.into_bytes(), serializer);}
                }
                
                impl SseEncode for crate::api::context::online::AudioContextLatencyCategory {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {match self {crate::api::context::online::AudioContextLatencyCategory::Balanced => { <i32>::sse_encode(0, serializer);  }
crate::api::context::online::AudioContextLatencyCategory::Interactive => { <i32>::sse_encode(1, serializer);  }
crate::api::context::online::AudioContextLatencyCategory::Playback => { <i32>::sse_encode(2, serializer);  }
crate::api::context::online::AudioContextLatencyCategory::Custom(field0) => { <i32>::sse_encode(3, serializer); <f64>::sse_encode(field0, serializer);
 }
 }}
                }
                
                impl SseEncode for crate::api::context::online::AudioContextOptions {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<crate::api::context::online::AudioContextLatencyCategory>::sse_encode(self.latency_hint, serializer);
<Option<f32>>::sse_encode(self.sample_rate, serializer);
<String>::sse_encode(self.sink_id, serializer);
<crate::api::context::online::AudioContextRenderSizeCategory>::sse_encode(self.render_size_hint, serializer);}
                }
                
                impl SseEncode for crate::api::context::online::AudioContextRenderSizeCategory {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<i32>::sse_encode(match self {crate::api::context::online::AudioContextRenderSizeCategory::Default => { 0 }
 _ => { unimplemented!(""); }}, serializer);}
                }
                
                impl SseEncode for crate::api::spatial::AudioListener {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<RustAutoOpaqueMoi<AudioParam>>::sse_encode(self.position_x, serializer);
<RustAutoOpaqueMoi<AudioParam>>::sse_encode(self.position_y, serializer);
<RustAutoOpaqueMoi<AudioParam>>::sse_encode(self.position_z, serializer);
<RustAutoOpaqueMoi<AudioParam>>::sse_encode(self.forward_x, serializer);
<RustAutoOpaqueMoi<AudioParam>>::sse_encode(self.forward_y, serializer);
<RustAutoOpaqueMoi<AudioParam>>::sse_encode(self.forward_z, serializer);
<RustAutoOpaqueMoi<AudioParam>>::sse_encode(self.up_x, serializer);
<RustAutoOpaqueMoi<AudioParam>>::sse_encode(self.up_y, serializer);
<RustAutoOpaqueMoi<AudioParam>>::sse_encode(self.up_z, serializer);}
                }
                
                impl SseEncode for crate::api::param::AutomationRate {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<i32>::sse_encode(match self {crate::api::param::AutomationRate::A => { 0 }
crate::api::param::AutomationRate::K => { 1 }
 _ => { unimplemented!(""); }}, serializer);}
                }
                
                impl SseEncode for bool {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {serializer.cursor.write_u8(self as _).unwrap();}
                }
                
                impl SseEncode for f32 {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {serializer.cursor.write_f32::<NativeEndian>(self).unwrap();}
                }
                
                impl SseEncode for f64 {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {serializer.cursor.write_f64::<NativeEndian>(self).unwrap();}
                }
                
                impl SseEncode for i32 {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {serializer.cursor.write_i32::<NativeEndian>(self).unwrap();}
                }
                
                impl SseEncode for Vec<Vec<f32>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<i32>::sse_encode(self.len() as _, serializer);
        for item in self { <Vec<f32>>::sse_encode(item, serializer); }}
                }
                
                impl SseEncode for Vec<f32> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<i32>::sse_encode(self.len() as _, serializer);
        for item in self { <f32>::sse_encode(item, serializer); }}
                }
                
                impl SseEncode for Vec<u8> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<i32>::sse_encode(self.len() as _, serializer);
        for item in self { <u8>::sse_encode(item, serializer); }}
                }
                
                impl SseEncode for Option<f32> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<bool>::sse_encode(self.is_some(), serializer);
                if let Some(value) = self {
                    <f32>::sse_encode(value, serializer);
                }}
                }
                
                impl SseEncode for Option<Vec<f32>> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<bool>::sse_encode(self.is_some(), serializer);
                if let Some(value) = self {
                    <Vec<f32>>::sse_encode(value, serializer);
                }}
                }
                
                impl SseEncode for crate::api::periodic_wave::PeriodicWaveOptions {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<Option<Vec<f32>>>::sse_encode(self.real, serializer);
<Option<Vec<f32>>>::sse_encode(self.imag, serializer);
<bool>::sse_encode(self.disable_normalization, serializer);}
                }
                
                impl SseEncode for (f32,f32,) {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<f32>::sse_encode(self.0, serializer);
<f32>::sse_encode(self.1, serializer);}
                }
                
                impl SseEncode for u8 {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {serializer.cursor.write_u8(self).unwrap();}
                }
                
                impl SseEncode for () {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
                }
                
                impl SseEncode for usize {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {serializer.cursor.write_u64::<NativeEndian>(self as _).unwrap();}
                }
                


        
        
        #[cfg(not(target_family = "wasm"))]
        #[path = "frb_generated.io.rs"]
        mod io;
        #[cfg(not(target_family = "wasm"))]
        pub use io::*;
        
        
        /// cbindgen:ignore
        #[cfg(target_family = "wasm")]
        #[path = "frb_generated.web.rs"]
        mod web;
        #[cfg(target_family = "wasm")]
        pub use web::*;
        
        